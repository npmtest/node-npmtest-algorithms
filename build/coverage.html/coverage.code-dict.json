{"/home/travis/build/npmtest/node-npmtest-algorithms/test.js":"/* istanbul instrument in package npmtest_algorithms */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-algorithms/lib.npmtest_algorithms.js":"/* istanbul instrument in package npmtest_algorithms */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_algorithms = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_algorithms = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-algorithms/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-algorithms && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_algorithms */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_algorithms\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_algorithms.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_algorithms.rollup.js'] =\n            local.assetsDict['/assets.npmtest_algorithms.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_algorithms.__dirname + '/lib.npmtest_algorithms.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-algorithms/node_modules/algorithms/index.js":"'use strict';\n\nvar lib = {\n  DataStructures: require('./data_structures'),\n  Graph: require('./graph'),\n  Geometry: require('./geometry'),\n  Math: require('./math'),\n  Search: require('./search'),\n  Sorting: require('./sorting'),\n  String: require('./string')\n};\n\nmodule.exports = lib;\n","/home/travis/build/npmtest/node-npmtest-algorithms/node_modules/algorithms/data_structures.js":"'use strict';\n\n// Data Structures\nmodule.exports = {\n  AVLTree: require('./data_structures/avl_tree'),\n  BST: require('./data_structures/bst'),\n  Treap: require('./data_structures/treap'),\n  Graph: require('./data_structures/graph'),\n  HashTable: require('./data_structures/hash_table'),\n  Heap: require('./data_structures/heap'),\n  LinkedList: require('./data_structures/linked_list'),\n  PriorityQueue: require('./data_structures/priority_queue'),\n  Queue: require('./data_structures/queue'),\n  Stack: require('./data_structures/stack'),\n  Set: require('./data_structures/set'),\n  DisjointSetForest: require('./data_structures/disjoint_set_forest'),\n  FenwickTree: require('./data_structures/fenwick_tree')\n};\n","/home/travis/build/npmtest/node-npmtest-algorithms/node_modules/algorithms/data_structures/avl_tree.js":"'use strict';\n\n/**\n * AVL Tree\n */\nfunction AVLTree() {\n  this.root = null;\n}\n\n/**\n * Tree node\n */\nfunction Node(value, left, right, parent, height) {\n  this.value = value;\n  this.left = left;\n  this.right = right;\n  this.parent = parent;\n  this.height = height;\n}\n\n/**\n * Calculates the height of a node based on height\n * property of all his children.\n */\nAVLTree.prototype.getNodeHeight = function (node) {\n  var height = 1;\n  if (node.left !== null && node.right !== null) {\n    height = Math.max(node.left.height, node.right.height) + 1;\n  } else if (node.left !== null) {\n    height = node.left.height + 1;\n  } else if (node.right !== null) {\n    height = node.right.height + 1;\n  }\n  return height;\n};\n\n/**\n * Verifies if the given node is balanced.\n */\nAVLTree.prototype.isNodeBalanced = function (node) {\n  var isBalanced = true;\n\n  if (node.left !== null && node.right !== null) {\n    isBalanced = (Math.abs(node.left.height - node.right.height) <= 1);\n  } else if (node.right !== null && node.left === null) {\n    isBalanced = node.right.height < 2;\n  } else if (node.left !== null && node.right === null) {\n    isBalanced = node.left.height < 2;\n  }\n  return isBalanced;\n};\n\n/**\n * When a removal happens, some nodes need to be\n * restructured. Gets and return these nodes.\n */\nAVLTree.prototype.getNodesToRestructureAfterRemove = function (traveledNodes) {\n  // z is last traveled node - imbalance found at z\n  var zIndex = traveledNodes.length - 1;\n  var z = traveledNodes[zIndex];\n\n  // y should be child of z with larger height\n  // (cannot be ancestor of removed node)\n  var y;\n  if (z.left !== null && z.right !== null) {\n    y = (z.left === y) ? z.right : z.left;\n  } else if (z.left !== null && z.right === null) {\n    y = z.left;\n  } else if (z.right !== null && z.left === null) {\n    y = z.right;\n  }\n\n  // x should be tallest child of y\n  // If children same height, x should be child of y\n  // that has same orientation as z to y\n  var x;\n  if (y.left !== null && y.right !== null) {\n    if (y.left.height > y.right.height) {\n      x = y.left;\n    } else if (y.left.height < y.right.height) {\n      x = y.right;\n    } else if (y.left.height === y.right.height) {\n      x = (z.left === y) ? y.left : y.right;\n    }\n  } else if (y.left !== null && y.right === null) {\n    x = y.left;\n  } else if (y.right !== null && y.left === null) {\n    x = y.right;\n  }\n  return [x, y, z];\n};\n\n/**\n * When a insertion happens, some nodes need to be\n * restructured. Gets and return these nodes.\n */\nAVLTree.prototype.getNodesToRestructureAfterInsert = function (traveledNodes) {\n  // z is last traveled node - imbalance found at z\n  var zIndex = traveledNodes.length - 1;\n  var z = traveledNodes[zIndex];\n\n  // y should be child of z with larger height\n  // (must be ancestor of inserted node)\n  // therefore, last traveled node is correct.\n  var yIndex = traveledNodes.length - 2;\n  var y = traveledNodes[yIndex];\n\n  // x should be tallest child of y\n  // If children same height, x should be ancestor\n  // of inserted node (in traveled path)\n  var x;\n  if (y.left !== null && y.right !== null) {\n    if (y.left.height > y.right.height) {\n      x = y.left;\n    } else if (y.left.height < y.right.height) {\n      x = y.right;\n    } else if (y.left.height === y.right.height) {\n      var xIndex = traveledNodes.length - 3;\n      x = traveledNodes[xIndex];\n    }\n  } else if (y.left !== null && y.right === null) {\n    x = y.left;\n  } else if (y.right !== null && y.left === null) {\n    x = y.right;\n  }\n  return [x, y, z];\n};\n\n/**\n * Keep the height balance property by walking to\n * root and checking for invalid heights.\n */\nAVLTree.prototype.keepHeightBalance = function (node, afterRemove) {\n  var current = node;\n  var traveledNodes = [];\n  while (current !== null) {\n    traveledNodes.push(current);\n    current.height = this.getNodeHeight(current);\n    if (!this.isNodeBalanced(current)) {\n      var nodesToBeRestructured = (afterRemove) ?\n        this.getNodesToRestructureAfterRemove(traveledNodes) :\n        this.getNodesToRestructureAfterInsert(traveledNodes);\n      this.restructure(nodesToBeRestructured);\n    }\n    current = current.parent;\n  }\n};\n\n/**\n * Identifies and calls the appropriate pattern\n * rotator.\n */\nAVLTree.prototype.restructure = function (nodesToRestructure) {\n  var x = nodesToRestructure[0];\n  var y = nodesToRestructure[1];\n  var z = nodesToRestructure[2];\n\n  // Determine Rotation Pattern\n  if (z.right === y && y.right === x) {\n    this.rightRight(x, y, z);\n  } else if (z.left === y && y.left === x) {\n    this.leftLeft(x, y, z);\n  } else if (z.right === y && y.left === x) {\n    this.rightLeft(x, y, z);\n  } else if (z.left === y && y.right === x) {\n    this.leftRight(x, y, z);\n  }\n};\n\n/**\n * Right-right rotation pattern.\n */\nAVLTree.prototype.rightRight = function (x, y, z) {\n  // pass z parent to y and move y's left to z's right\n  if (z.parent !== null) {\n    var orientation = (z.parent.left === z) ? 'left' : 'right';\n    z.parent[orientation] = y;\n    y.parent = z.parent;\n  } else {\n    this.root = y;\n    y.parent = null;\n  }\n\n  // z adopts y's left.\n  z.right = y.left;\n  if (z.right !== null) {\n    z.right.parent = z;\n  }\n  // y adopts z\n  y.left = z;\n  z.parent = y;\n\n  // Correct each nodes height - order matters, children first\n  x.height = this.getNodeHeight(x);\n  z.height = this.getNodeHeight(z);\n  y.height = this.getNodeHeight(y);\n};\n\n/**\n * Left-left rotation pattern.\n */\nAVLTree.prototype.leftLeft = function (x, y, z) {\n  //pass z parent to y and move y's right to z's left\n  if (z.parent !== null) {\n    var orientation = (z.parent.left === z) ? 'left' : 'right';\n    z.parent[orientation] = y;\n    y.parent = z.parent;\n  } else {\n    this.root = y;\n    y.parent = null;\n  }\n\n  z.left = y.right;\n  if (z.left !== null) {\n    z.left.parent = z;\n  }\n  //fix y right child\n  y.right = z;\n  z.parent = y;\n\n  // Correct each nodes height - order matters, children first\n  x.height = this.getNodeHeight(x);\n  z.height = this.getNodeHeight(z);\n  y.height = this.getNodeHeight(y);\n};\n\n/**\n * Right-left rotation pattern.\n */\nAVLTree.prototype.rightLeft = function (x, y, z) {\n  //pass z parent to x\n  if (z.parent !== null) {\n    var orientation = (z.parent.left === z) ? 'left' : 'right';\n    z.parent[orientation] = x;\n    x.parent = z.parent;\n  } else {\n    this.root = x;\n    x.parent = null;\n  }\n\n  // Adoptions\n  z.right = x.left;\n  if (z.right !== null) {\n    z.right.parent = z;\n  }\n  y.left = x.right;\n  if (y.left !== null) {\n    y.left.parent = y;\n  }\n\n  // Point to new children (x new parent)\n  x.left = z;\n  x.right = y;\n  x.left.parent = x;\n  x.right.parent = x;\n\n  // Correct each nodes height - order matters, children first\n  y.height = this.getNodeHeight(y);\n  z.height = this.getNodeHeight(z);\n  x.height = this.getNodeHeight(x);\n};\n\n/**\n * Left-right rotation pattern.\n */\nAVLTree.prototype.leftRight = function (x, y, z) {\n  //pass z parent to x\n  if (z.parent !== null) {\n    var orientation = (z.parent.left === z) ? 'left' : 'right';\n    z.parent[orientation] = x;\n    x.parent = z.parent;\n  } else {\n    this.root = x;\n    x.parent = null;\n  }\n\n  // Adoptions\n  z.left = x.right;\n  if (z.left !== null) {\n    z.left.parent = z;\n  }\n  y.right = x.left;\n  if (y.right !== null) {\n    y.right.parent = y;\n  }\n\n  // Point to new children (x new parent)\n  x.right = z;\n  x.left = y;\n  x.left.parent = x;\n  x.right.parent = x;\n\n  // Correct each nodes height - order matters, children first\n  y.height = this.getNodeHeight(y);\n  z.height = this.getNodeHeight(z);\n  x.height = this.getNodeHeight(x);\n};\n\n/**\n * Inserts a value as a Node of an AVL Tree.\n */\nAVLTree.prototype.insert = function (value, current) {\n  if (this.root === null) {\n    this.root = new Node(value, null, null, null, 1);\n    this.keepHeightBalance(this.root);\n    return;\n  }\n\n  var insertKey;\n  current = current || this.root;\n  if (current.value > value) {\n    insertKey = 'left';\n  } else {\n    insertKey = 'right';\n  }\n\n  if (!current[insertKey]) {\n    current[insertKey] = new Node(value, null, null, current);\n    this.keepHeightBalance(current[insertKey], false);\n  } else {\n    this.insert(value, current[insertKey]);\n  }\n};\n\n/**\n * In-order traversal from the given node.\n */\nAVLTree.prototype.inOrder = function (current, callback) {\n  if (!current) {\n    return;\n  }\n  this.inOrder(current.left, callback);\n  if (typeof callback === 'function') {\n    callback(current);\n  }\n  this.inOrder(current.right, callback);\n};\n\n/**\n * Post-order traversal from the given node.\n */\nAVLTree.prototype.postOrder = function (current, callback) {\n  if (!current) {\n    return;\n  }\n\n  this.postOrder(current.left, callback);\n  this.postOrder(current.right, callback);\n  if (typeof callback === 'function') {\n    callback(current);\n  }\n};\n\n/**\n * Pre-order traversal from the given node.\n */\nAVLTree.prototype.preOrder = function (current, callback) {\n  if (!current) {\n    return;\n  }\n  if (typeof callback === 'function') {\n    callback(current);\n  }\n  this.preOrder(current.left, callback);\n  this.preOrder(current.right, callback);\n};\n\n/**\n * Finds a node by its value.\n */\nAVLTree.prototype.find = function (value) {\n  return this._find(value, this.root);\n};\n\n/**\n * Finds a node by its value in the given sub-tree.\n */\nAVLTree.prototype._find = function (value, current) {\n  if (!current) {\n    return null;\n  }\n\n  var node;\n  if (current.value === value) {\n    node = current;\n  } else if (current.value > value) {\n    node = this._find(value, current.left);\n  } else if (current.value < value) {\n    node = this._find(value, current.right);\n  }\n\n  return node;\n};\n\n/**\n * Replaces the given child with the new one,\n * for the given parent.\n */\nAVLTree.prototype.replaceChild = function (parent, oldChild, newChild) {\n  if (parent === null) {\n    this.root = newChild;\n    if (this.root !== null) {\n      this.root.parent = null;\n    }\n  } else {\n    if (parent.left === oldChild) {\n      parent.left = newChild;\n    } else {\n      parent.right = newChild;\n    }\n    if (newChild) {\n      newChild.parent = parent;\n    }\n  }\n};\n\n/**\n * Removes a node by its value.\n */\nAVLTree.prototype.remove = function (value) {\n  var node = this.find(value);\n  if (!node) {\n    return false;\n  }\n\n  if (node.left && node.right) {\n    var min = this.findMin(node.right);\n    var temp = node.value;\n    node.value = min.value;\n    min.value = temp;\n    return this.remove(min);\n  } else if (node.left) {\n    this.replaceChild(node.parent, node, node.left);\n    this.keepHeightBalance(node.left, true);\n  } else if (node.right) {\n    this.replaceChild(node.parent, node, node.right);\n    this.keepHeightBalance(node.right, true);\n  } else {\n    this.replaceChild(node.parent, node, null);\n    this.keepHeightBalance(node.parent, true);\n  }\n  return true;\n};\n\n/**\n * Finds the node with minimum value in the given\n * sub-tree.\n */\nAVLTree.prototype._findMin = function (node, current) {\n  current = current || {\n    value: Infinity\n  };\n  if (!node) {\n    return current;\n  }\n  if (current.value > node.value) {\n    current = node;\n  }\n  return this._findMin(node.left, current);\n};\n\n/**\n * Finds the node with maximum value in the given\n * sub-tree.\n */\nAVLTree.prototype._findMax = function (node, current) {\n  current = current || {\n    value: -Infinity\n  };\n  if (!node) {\n    return current;\n  }\n  if (current.value < node.value) {\n    current = node;\n  }\n  return this._findMax(node.right, current);\n};\n\n/**\n * Finds the node with minimum value in the whole tree.\n */\nAVLTree.prototype.findMin = function () {\n  return this._findMin(this.root);\n};\n\n/**\n * Finds the node with maximum value in the whole tree.\n */\nAVLTree.prototype.findMax = function () {\n  return this._findMax(this.root);\n};\n\n/**\n * Verifies if the tree is balanced.\n */\nAVLTree.prototype.isTreeBalanced = function () {\n  var current = this.root;\n\n  if (!current) {\n    return true;\n  }\n  return this._isBalanced(current._left) &&\n    this._isBalanced(current._right) &&\n    Math.abs(this._getNodeHeight(current._left) -\n      this._getNodeHeight(current._right)) <= 1;\n};\n\n/**\n * Calculates the height of the tree based on height\n * property.\n */\nAVLTree.prototype.getTreeHeight = function () {\n  var current = this.root;\n\n  if (!current) {\n    return 0;\n  }\n  return 1 + Math.max(this.getNodeHeight(current._left),\n    this._getNodeHeight(current._right));\n};\n\nmodule.exports = AVLTree;\n","/home/travis/build/npmtest/node-npmtest-algorithms/node_modules/algorithms/data_structures/bst.js":"'use strict';\nvar Comparator = require('../util/comparator');\n\n/**\n * Binary Search Tree\n */\nfunction BST(compareFn) {\n  this.root = null;\n  this._size = 0;\n  /**\n   * @var Comparator\n   */\n  this._comparator = new Comparator(compareFn);\n\n  /**\n   * Read-only property for the size of the tree\n   */\n  Object.defineProperty(this, 'size', {\n    get: function () { return this._size; }.bind(this)\n  });\n}\n\n/**\n * Tree node\n */\nfunction Node(value, parent) {\n  this.value = value;\n  this.parent = parent;\n  this.left = null;\n  this.right = null;\n}\n\n/**\n * Insert elements to the tree respecting the BST restrictions\n */\nBST.prototype.insert = function (value, parent) {\n  // Set the root as the initial insertion point\n  // if it has not been passed\n  if (!parent) {\n    if (!this.root) {\n      this.root = new Node(value);\n      this._size++;\n      return;\n    }\n    parent = this.root;\n  }\n\n  var child = this._comparator.lessThan(value, parent.value) ? 'left' : 'right';\n  if (parent[child]) {\n    this.insert(value, parent[child]);\n  } else {\n    parent[child] = new Node(value, parent);\n    this._size++;\n  }\n};\n\n/**\n * Returns if a tree contains an element in O(lg n)\n */\nBST.prototype.contains = function (e) {\n  return !!this._find(e);\n};\n\nBST.prototype._find = function (e, root) {\n\n  if (!root) {\n    if (this.root) root = this.root;\n    else return false;\n  }\n\n  if (root.value === e)\n    return root;\n\n  if (this._comparator.lessThan(e, root.value))\n    return root.left && this._find(e, root.left);\n\n  if (this._comparator.greaterThan(e, root.value))\n    return root.right && this._find(e, root.right);\n};\n\n/**\n * Substitute two nodes\n */\nBST.prototype._replaceNodeInParent = function (currNode, newNode) {\n  var parent = currNode.parent;\n  if (parent) {\n    parent[currNode === parent.left ? 'left' : 'right'] = newNode;\n    if (newNode)\n      newNode.parent = parent;\n  } else {\n    this.root = newNode;\n  }\n};\n\n/**\n * Find the minimum value in a tree\n */\nBST.prototype._findMin = function (root) {\n  var minNode = root;\n  while (minNode.left) {\n    minNode = minNode.left;\n  }\n  return minNode;\n};\n\n/**\n * Remove an element from the BST\n */\nBST.prototype.remove = function (e) {\n  var node = this._find(e);\n  if (!node) {\n    throw new Error('Item not found in the tree');\n  }\n\n  if (node.left && node.right) {\n    /**\n     * If the node to be removed has both left and right children,\n     * replace the node's value by the minimum value of the right\n     * sub-tree, and remove the leave containing the value\n     */\n    var successor = this._findMin(node.right);\n    this.remove(successor.value);\n    node.value = successor.value;\n  } else {\n    /**\n     * If the node is a leaf, just make the parent point to null,\n     * and if it has one child, make the parent point to this child\n     * instead\n     */\n    this._replaceNodeInParent(node, node.left || node.right);\n    this._size--;\n  }\n};\n\nmodule.exports = BST;\n","/home/travis/build/npmtest/node-npmtest-algorithms/node_modules/algorithms/util/comparator.js":"'use strict';\n\n/**\n * Initialize the comparator object with a compare function\n *\n * If the function is not passed, it will use the default\n * compare signs (<, > and ==)\n *\n * @param { Function } compareFn\n */\nfunction Comparator(compareFn) {\n  if (compareFn) {\n    this.compare = compareFn;\n  }\n}\n\n/**\n * Default implementation for the compare function\n */\nComparator.prototype.compare = function (a, b) {\n  if (a === b) return 0;\n  return a < b ? -1 : 1;\n};\n\nComparator.prototype.lessThan = function (a, b) {\n  return this.compare(a, b) < 0;\n};\n\nComparator.prototype.lessThanOrEqual = function (a, b) {\n  return this.lessThan(a, b) || this.equal(a, b);\n};\n\nComparator.prototype.greaterThan = function (a, b) {\n  return this.compare(a, b) > 0;\n};\n\nComparator.prototype.greaterThanOrEqual = function (a, b) {\n  return this.greaterThan(a, b) || this.equal(a, b);\n};\n\nComparator.prototype.equal = function (a, b) {\n  return this.compare(a, b) === 0;\n};\n\n/**\n * Reverse the comparison function to use the opposite logic, e.g:\n * this.compare(a, b) => 1\n * this.reverse();\n * this.compare(a, b) => -1\n */\nComparator.prototype.reverse = function () {\n  var originalCompareFn = this.compare;\n  this.compare = function (a, b) {\n    return originalCompareFn(b, a);\n  };\n};\n\nmodule.exports = Comparator;\n","/home/travis/build/npmtest/node-npmtest-algorithms/node_modules/algorithms/data_structures/treap.js":"'use strict';\n\n/**\n * Tree node\n */\nfunction Node(value, left, right) {\n  this.value = value;\n  this.children = [left, right];\n  this.size = 1;\n  this.height = 1;\n  this.key = Math.random();\n}\n\n/**\n * Computer the number of childnodes\n */\nNode.prototype.resize = function () {\n  this.size = (this.children[0] ? this.children[0].size : 0) \n            + (this.children[1] ? this.children[1].size : 0) + 1;\n  this.height = Math.max(this.children[0] ? this.children[0].height : 0,\n  \t\t\t\t\t\t this.children[1] ? this.children[1].height : 0) + 1;\n  return this;\n};\n\n/**\n * Zigzag rotate of tree nodes\n */\nNode.prototype.rotate = function (side) {\n  var temp = this.children[side];\n\n  // Rotate\n  this.children[side] = temp.children[1 - side];\n  temp.children[1 - side] = this;\n\n  this.resize();\n  temp.resize();\n\n  return temp;\n};\n\n/**\n * Treap\n */\nfunction Treap() {\n  this.root = null;\n}\n\n/**\n * Insert new value into the subtree of `node`\n */\nTreap.prototype._insert = function (node, value) {\n  if (node === null) {\n    return new Node(value, null, null);\n  }\n\n  // Passing to childnodes and update\n  var side = ~~(value > node.value);\n  node.children[side] = this._insert(node.children[side], value);\n\n  // Keep it balance\n  if (node.children[side].key < node.key) {\n\treturn node.rotate(side);\n  } else {\n\treturn node.resize();\n  }\n};\n\nTreap.prototype._find = function (node, value) {\n  if (node === null) {\n    // Empty tree\n    return false;\n  }\n  if (node.value === value) {\n    // Found!\n    return true;\n  }\n\n  // Search within childnodes\n  var side = ~~(value > node.value);\n  return this._find(node.children[side], value);\n};\n\nTreap.prototype._minimum = function (node) {\n  if (node === null) {\n    // Empty tree, returns Infinity\n    return Infinity;\n  }\n\n  return Math.min(node.value, this._minimum(node.children[0]));\n};\n\nTreap.prototype._maximum = function (node) {\n  if (node === null) {\n    // Empty tree, returns -Infinity\n    return -Infinity;\n  }\n\n  return Math.max(node.value, this._maximum(node.children[1]));\n};\n\nTreap.prototype._remove = function (node, value) {\n  if (node === null) {\n    // Empty node, value not found\n    return null;\n  }\n\n  var side;\n\n  if (node.value === value) {\n    if (node.children[0] === null && node.children[1] === null) {\n      // It's a leaf, set to null\n      return null;\n    }\n\n\t// Rotate to a subtree and remove it\n\tside = (node.children[0] === null ? 1 : 0);\n\tnode = node.rotate(side);\n  \tnode.children[1 - side] = this._remove(node.children[1 - side], value);\n  \treturn node.resize();\n  } else {\n    side = ~~(value > node.value);\n    node.children[side] = this._remove(node.children[side], value);\n  \treturn node.resize();\n  }\n};\n\nTreap.prototype.insert = function (value) {\n  this.root = this._insert(this.root, value);\n};\n\nTreap.prototype.find = function (value) {\n  return this._find(this.root, value);\n};\n\nTreap.prototype.minimum = function () {\n  return this._minimum(this.root);\n};\n\nTreap.prototype.maximum = function () {\n  return this._maximum(this.root);\n};\n\nTreap.prototype.remove = function (value) {\n  this.root = this._remove(this.root, value);\n};\n\nTreap.prototype.size = function () {\n  return this.root ? this.root.size : 0;\n};\n\nTreap.prototype.height = function () {\n  return this.root ? this.root.height : 0;\n};\n\nmodule.exports = Treap;\n","/home/travis/build/npmtest/node-npmtest-algorithms/node_modules/algorithms/data_structures/graph.js":"'use strict';\n\nvar HashSet = require('./set');\n\n/**\n * Adjacency list representation of a graph\n * @param {bool} directed\n */\nfunction Graph(directed) {\n  this.directed = (directed === undefined ? true : !!directed);\n  this.adjList = Object.create(null);\n  this.vertices = new HashSet();\n}\n\n// Normalize vertex labels as strings\nvar _ = function (v) {\n  return '' + v;\n};\n\nGraph.prototype.addVertex = function (v) {\n  v = _(v);\n  if (this.vertices.contains(v)) {\n    throw new Error('Vertex \"' + v + '\" has already been added');\n  }\n  this.vertices.add(v);\n  this.adjList[v] = Object.create(null);\n};\n\nGraph.prototype.addEdge = function (a, b, w) {\n  a = _(a);\n  b = _(b);\n  // If no weight is assigned to the edge, 1 is the default\n  w = (w === undefined ? 1 : w);\n\n  if (!this.adjList[a]) this.addVertex(a);\n  if (!this.adjList[b]) this.addVertex(b);\n\n  // If there's already another edge with the same origin and destination\n  // sum with the current one\n  this.adjList[a][b] = (this.adjList[a][b] || 0) + w;\n\n  // If the graph is not directed add the edge in both directions\n  if (!this.directed) {\n    this.adjList[b][a] = (this.adjList[b][a] || 0) + w;\n  }\n};\n\nGraph.prototype.neighbors = function (v) {\n  return Object.keys(this.adjList[_(v)]);\n};\n\nGraph.prototype.edge = function (a, b) {\n  return this.adjList[_(a)][_(b)];\n};\n\nmodule.exports = Graph;\n","/home/travis/build/npmtest/node-npmtest-algorithms/node_modules/algorithms/data_structures/set.js":"'use strict';\n\nvar HashTable = require('./hash_table');\n\n/**\n * Typical representation of a mathematical set\n * No restriction on element types\n *   i.e. set.add(1,'a', \"b\", { \"foo\" : \"bar\" })\n */\nvar HashSet = function () {\n  this._elements = new HashTable(arguments.length);\n  this.add.apply(this, arguments);\n\n  Object.defineProperty(this, 'size', {\n    get: function () {\n      return this._elements.size;\n    }\n  });\n};\n\nHashSet.prototype.add = function () {\n  for (var i = 0; i < arguments.length; i++) {\n    this._elements.put(arguments[i], true);\n  }\n  return this;\n};\n\nHashSet.prototype.remove = function () {\n  for (var i = 0; i < arguments.length; i++) {\n    this._elements.del(arguments[i]);\n  }\n  return this;\n};\n\nHashSet.prototype.contains = function (e) {\n  return this._elements.get(e) !== undefined;\n};\n\nHashSet.prototype.forEach = function (fn) {\n  this._elements.forEach(fn);\n};\n\nmodule.exports = HashSet;\n","/home/travis/build/npmtest/node-npmtest-algorithms/node_modules/algorithms/data_structures/hash_table.js":"'use strict';\n\nvar LinkedList = require('./linked_list');\n\nfunction HashTable(initialCapacity) {\n  this._table = new Array(initialCapacity || 64);\n  this._items = 0;\n\n  Object.defineProperty(this, 'capacity', {\n    get: function () {\n      return this._table.length;\n    }\n  });\n\n  Object.defineProperty(this, 'size', {\n    get: function () {\n      return this._items;\n    }\n  });\n}\n\n/**\n * (Same algorithm as Java's String.hashCode)\n * Returns a hash code for this string. The hash code for a String object is\n * computed as: s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]\n * using int arithmetic, where s[i] is the ith character of the string,\n * n is the length of the string, and ^ indicates exponentiation.\n * (The hash value of the empty string is zero.)\n */\nHashTable.prototype.hash = function (s) {\n  if (typeof s !== 'string') s = JSON.stringify(s);\n  var hash = 0;\n  for (var i = 0; i < s.length; i++) {\n    hash = ((hash << 5) - hash) + s.charCodeAt(i);\n    hash &= hash; // Keep it a 32bit int\n  }\n  return hash;\n};\n\nHashTable.prototype.get = function (key) {\n  var i = this._position(key);\n  var node;\n  if ((node = this._findInList(this._table[i], key))) {\n    return node.value.v;\n  }\n};\n\nHashTable.prototype.put = function (key, value) {\n  var i = this._position(key);\n  if (!this._table[i]) {\n    // Hashing with chaining\n    this._table[i] = new LinkedList();\n  }\n  var item = {k: key, v: value};\n\n  var node = this._findInList(this._table[i], key);\n  if (node) {\n    // if the key already exists in the list, replace\n    // by the current item\n    node.value = item;\n  } else {\n    this._table[i].add(item);\n    this._items++;\n\n    if (this._items === this.capacity) this._increaseCapacity();\n  }\n};\n\nHashTable.prototype.del = function (key) {\n  var i = this._position(key);\n  var node;\n\n  if ((node = this._findInList(this._table[i], key))) {\n    this._table[i].delNode(node);\n    this._items--;\n  }\n};\n\nHashTable.prototype._position = function (key) {\n  return Math.abs(this.hash(key)) % this.capacity;\n};\n\nHashTable.prototype._findInList = function (list, key) {\n  var node = list && list.head;\n  while (node) {\n    if (node.value.k === key) return node;\n    node = node.next;\n  }\n};\n\nHashTable.prototype._increaseCapacity = function () {\n  var oldTable = this._table;\n  this._table = new Array(2 * this.capacity);\n  this._items = 0;\n\n  for (var i = 0; i < oldTable.length; i++) {\n    var node = oldTable[i] && oldTable[i].head;\n    while (node) {\n      this.put(node.value.k, node.value.v);\n      node = node.next;\n    }\n  }\n};\n\nHashTable.prototype.forEach = function (fn) {\n  var applyFunction = function (linkedList) {\n    linkedList.forEach(function (elem) {\n      fn(elem.k, elem.v);\n    });\n  };\n\n  for (var i = 0; i < this._table.length; i++) {\n    if (this._table[i]) {\n      applyFunction(this._table[i]);\n    }\n  }\n};\n\nmodule.exports = HashTable;\n","/home/travis/build/npmtest/node-npmtest-algorithms/node_modules/algorithms/data_structures/linked_list.js":"'use strict';\n\n/**\n * Doubly-linked list\n */\nfunction LinkedList() {\n\n  this._length = 0;\n  this.head = null;\n  this.tail = null;\n\n  // Read-only length property\n  Object.defineProperty(this, 'length', {\n    get: function () {\n      return this._length;\n    }.bind(this)\n  });\n}\n\n/**\n * A linked list node\n */\nfunction Node(value) {\n  this.value = value;\n  this.prev = null;\n  this.next = null;\n}\n\n/**\n * Whether the list is empty\n *\n * @return Boolean\n */\nLinkedList.prototype.isEmpty = function () {\n  return this.length === 0;\n};\n\n/**\n * Adds the element to the end of the list or to the desired index\n *\n * @param { Object } n\n * @param { Number } index\n */\nLinkedList.prototype.add = function (n, index) {\n  if (index > this.length || index < 0) {\n    throw new Error('Index out of bounds');\n  }\n\n  var node = new Node(n);\n\n  if (index !== undefined && index < this.length) {\n    var prevNode,\n        nextNode;\n\n    if (index === 0) {\n      // Insert in the beginning\n      nextNode = this.head;\n      this.head = node;\n    } else {\n      nextNode = this.getNode(index);\n      prevNode = nextNode.prev;\n      prevNode.next = node;\n      node.prev = prevNode;\n    }\n    nextNode.prev = node;\n    node.next = nextNode;\n  } else {\n    // Insert at the end\n    if (!this.head) this.head = node;\n\n    if (this.tail) {\n      this.tail.next = node;\n      node.prev = this.tail;\n    }\n    this.tail = node;\n  }\n\n  this._length++;\n};\n\n/**\n * Return the value associated to the Node on the given index\n *\n * @param { Number } index\n * @return misc\n */\nLinkedList.prototype.get = function (index) {\n  return this.getNode(index).value;\n};\n\n/**\n * O(n) get\n *\n * @param { Number } index\n * @return Node\n */\nLinkedList.prototype.getNode = function (index) {\n  if (index >= this.length || index < 0) {\n    throw new Error('Index out of bounds');\n  }\n\n  var node = this.head;\n  for (var i = 1; i <= index; i++) {\n    node = node.next;\n  }\n\n  return node;\n};\n\n/**\n * Delete the element in the indexth position\n *\n * @param { Number } index\n */\nLinkedList.prototype.del = function (index) {\n  if (index >= this.length || index < 0) {\n    throw new Error('Index out of bounds');\n  }\n\n  this.delNode(this.getNode(index));\n};\n\nLinkedList.prototype.delNode = function (node) {\n  if (node === this.tail) {\n    // node is the last element\n    this.tail = node.prev;\n  } else {\n    node.next.prev = node.prev;\n  }\n  if (node === this.head) {\n    // node is the first element\n    this.head = node.next;\n  } else {\n    node.prev.next = node.next;\n  }\n\n  this._length--;\n};\n\n/**\n * Performs the fn function with each element in the list\n */\nLinkedList.prototype.forEach = function (fn) {\n  var node = this.head;\n  while (node) {\n    fn(node.value);\n    node = node.next;\n  }\n};\n\nmodule.exports = LinkedList;\n","/home/travis/build/npmtest/node-npmtest-algorithms/node_modules/algorithms/data_structures/heap.js":"'use strict';\nvar Comparator = require('../util/comparator');\n\n/**\n * Basic Heap structure\n */\nfunction MinHeap(compareFn) {\n  this._elements = [null];\n  this._comparator = new Comparator(compareFn);\n\n  Object.defineProperty(this, 'n', {\n    get: function () {\n      return this._elements.length - 1;\n    }.bind(this)\n  });\n}\n\nMinHeap.prototype._swap = function (a, b) {\n  var tmp = this._elements[a];\n  this._elements[a] = this._elements[b];\n  this._elements[b] = tmp;\n};\n\nMinHeap.prototype.isEmpty = function () {\n  return this.n === 0;\n};\n\nMinHeap.prototype.insert = function (e) {\n  this._elements.push(e);\n  this._siftUp();\n};\n\nMinHeap.prototype.extract = function () {\n  var element = this._elements[1];\n\n  // Get the one from the bottom in insert it on top\n  // If this isn't already the last element\n  var last = this._elements.pop();\n  if (this.n) {\n    this._elements[1] = last;\n    this._siftDown();\n  }\n\n  return element;\n};\n\n/**\n * Sift up the last element\n * O(lg n)\n */\nMinHeap.prototype._siftUp = function () {\n  var i, parent;\n\n  for (i = this.n;\n      i > 1 && (parent = i >> 1) && this._comparator.greaterThan(\n        this._elements[parent], this._elements[i]);\n      i = parent) {\n    this._swap(parent, i);\n  }\n};\n\n/**\n * Sifts down the first element\n * O(lg n)\n */\nMinHeap.prototype._siftDown = function (i) {\n  var c;\n  for (i = i || 1; (c = i << 1) <= this.n; i = c) {\n    // checks which is the smaller child to compare with\n    if (c + 1 <= this.n && this._comparator.lessThan(\n          this._elements[c + 1], this._elements[c]))\n      // use the right child if it's lower than the left one\n      c++;\n    if (this._comparator.lessThan(this._elements[i],\n          this._elements[c]))\n      break;\n    this._swap(i, c);\n  }\n};\n\nMinHeap.prototype.heapify = function (a) {\n  if (a) {\n    this._elements = a;\n    this._elements.unshift(null);\n  }\n\n  for (var i = this.n >> 1; i > 0; i--) {\n    this._siftDown(i);\n  }\n};\n\nMinHeap.prototype.forEach = function (fn) {\n  // A copy is necessary in order to perform extract(),\n  // get the items in sorted order and then restore the original\n  // this._elements array\n  var elementsCopy = [];\n  var i;\n\n  for (i = 0; i < this._elements.length; i++) {\n    elementsCopy.push(this._elements[i]);\n  }\n\n  for (i = this.n; i > 0; i--) {\n    fn(this.extract());\n  }\n\n  this._elements = elementsCopy;\n};\n\n/**\n * Max Heap, keeps the highest element always on top\n *\n * To avoid code repetition, the Min Heap is used just with\n * a reverse comparator;\n */\nfunction MaxHeap(compareFn) {\n\n  MinHeap.call(this, compareFn);\n  this._comparator.reverse();\n}\n\nMaxHeap.prototype = new MinHeap();\n\nmodule.exports = {\n  MinHeap: MinHeap,\n  MaxHeap: MaxHeap\n};\n","/home/travis/build/npmtest/node-npmtest-algorithms/node_modules/algorithms/data_structures/priority_queue.js":"'use strict';\n\nvar MinHeap = require('./heap').MinHeap;\n\n/**\n * Extends the MinHeap with the only difference that\n * the heap operations are performed based on the priority of the element\n * and not on the element itself\n */\nfunction PriorityQueue(initialItems) {\n\n  var self = this;\n  MinHeap.call(this, function (a, b) {\n    return self.priority(a) < self.priority(b) ? -1 : 1;\n  });\n\n  this._priority = {};\n\n  initialItems = initialItems || {};\n  Object.keys(initialItems).forEach(function (item) {\n    self.insert(item, initialItems[item]);\n  });\n}\n\nPriorityQueue.prototype = new MinHeap();\n\nPriorityQueue.prototype.insert = function (item, priority) {\n  if (this._priority[item] !== undefined) {\n    return this.changePriority(item, priority);\n  }\n  this._priority[item] = priority;\n  MinHeap.prototype.insert.call(this, item);\n};\n\nPriorityQueue.prototype.extract = function (withPriority) {\n  var min = MinHeap.prototype.extract.call(this);\n  return withPriority ?\n    min && {item: min, priority: this._priority[min]} :\n    min;\n};\n\nPriorityQueue.prototype.priority = function (item) {\n  return this._priority[item];\n};\n\nPriorityQueue.prototype.changePriority = function (item, priority) {\n  this._priority[item] = priority;\n  this.heapify();\n};\n\nmodule.exports = PriorityQueue;\n","/home/travis/build/npmtest/node-npmtest-algorithms/node_modules/algorithms/data_structures/queue.js":"'use strict';\n\nvar LinkedList = require('./linked_list');\n\n/**\n * Queue (FIFO) using a Linked List as basis\n */\nfunction Queue() {\n  this._elements = new LinkedList();\n\n  Object.defineProperty(this, 'length', {\n    get: function () {\n      return this._elements.length;\n    }.bind(this)\n  });\n}\n\nQueue.prototype.isEmpty = function () {\n  return this._elements.isEmpty();\n};\n\n/**\n * Adds element to the end of the queue\n */\nQueue.prototype.push = function (e) {\n  this._elements.add(e);\n};\n\n/**\n * Pops the element in the beginning of the queue\n */\nQueue.prototype.pop = function () {\n  if (this.isEmpty()) {\n    throw new Error('Empty queue');\n  }\n  var e = this._elements.get(0);\n  this._elements.del(0);\n  return e;\n};\n\nQueue.prototype.peek = function () {\n  if (this.isEmpty()) {\n    throw new Error('Empty queue');\n  }\n\n  return this._elements.get(0);\n};\n\nQueue.prototype.forEach = function (fn) {\n  this._elements.forEach(fn);\n};\n\nmodule.exports = Queue;\n","/home/travis/build/npmtest/node-npmtest-algorithms/node_modules/algorithms/data_structures/stack.js":"'use strict';\n\nvar Queue = require('./queue');\n\n/**\n * Stack (LIFO) using a Linked List as basis\n */\nfunction Stack() {\n  Queue.call(this);\n}\n\n/**\n * Use a Queue as prototype and just overwrite\n * the push method to insert at the 0 position\n * instead of the end of the queue\n */\nStack.prototype = new Queue();\n\n/**\n * Adds element to the top of the stack\n */\nStack.prototype.push = function (e) {\n  this._elements.add(e, 0);\n};\n\nmodule.exports = Stack;\n","/home/travis/build/npmtest/node-npmtest-algorithms/node_modules/algorithms/data_structures/disjoint_set_forest.js":"'use strict';\n\n/**\n * Disjoint Set Forest data structure.\n * Allows fast subset merging and querying.\n * New elements lie in their own one-element subsets by default.\n *\n * @constructor\n */\nfunction DisjointSetForest() {\n  this._parents = {};\n  this._ranks = {};\n  this._sizes = {};\n}\n\n\nDisjointSetForest.prototype._introduce = function (element) {\n  if (!(element in this._parents)) {\n    this._parents[element] = element;\n    this._ranks[element] = 0;\n    this._sizes[element] = 1;\n  }\n};\n\n\n/**\n * Check if the elements belong to the same subset.\n * Complexity: O(A^-1) (inverse Ackermann function) amortized.\n *\n * @param {...*} element\n * @return {boolean}\n */\nDisjointSetForest.prototype.sameSubset = function (element) {\n  this._introduce(element);\n  var root = this.root(element);\n  return [].slice.call(arguments, 1).every(function (element) {\n    this._introduce(element);\n    return this.root(element) === root;\n  }.bind(this));\n};\n\n\n/**\n * Return the root element which represents the given element's subset.\n * The result does not depend on the choice of the element,\n *   but rather on the subset itself.\n * Complexity: O(A^-1) (inverse Ackermann function) amortized.\n *\n * @param {*} element\n * @return {*}\n */\nDisjointSetForest.prototype.root = function (element) {\n  this._introduce(element);\n  if (this._parents[element] !== element) {\n    this._parents[element] = this.root(this._parents[element]);\n  }\n  return this._parents[element];\n};\n\n\n/**\n * Return the size of the given element's subset.\n * Complexity: O(A^-1) (inverse Ackermann function) amortized.\n *\n * @param {*} element\n * @return {number}\n */\nDisjointSetForest.prototype.size = function (element) {\n  this._introduce(element);\n  return this._sizes[this.root(element)];\n};\n\n\n/**\n * Merge subsets containing two (or more) given elements into one.\n * Complexity: O(A^-1) (inverse Ackermann function) amortized.\n *\n * @param {*} element1\n * @param {*} element2\n * @param {...*}\n * @return {DisjointSetForest}\n */\nDisjointSetForest.prototype.merge = function merge(element1, element2) {\n  if (arguments.length > 2) {\n    merge.apply(this, [].slice.call(arguments, 1));\n  }\n\n  this._introduce(element1);\n  this._introduce(element2);\n  var root1 = this.root(element1);\n  var root2 = this.root(element2);\n\n  if (this._ranks[root1] < this._ranks[root2]) {\n    this._parents[root1] = root2;\n    this._sizes[root2] += this._sizes[root1];\n  }\n  else if (root1 !== root2) {\n    this._parents[root2] = root1;\n    this._sizes[root1] += this._sizes[root2];\n    if (this._ranks[root1] === this._ranks[root2]) {\n      this._ranks[root1] += 1;\n    }\n  }\n  return this;\n};\n\n\nmodule.exports = DisjointSetForest;\n","/home/travis/build/npmtest/node-npmtest-algorithms/node_modules/algorithms/data_structures/fenwick_tree.js":"'use strict';\n\n/**\n * Fenwick Tree (Binary Indexed Tree)\n *\n * The fenwick tree is a tree in the sense it represents a structure where\n * the leafs are the original array values and each parent has the sum of its\n * two children. E.g., for an array [1, 2, 3, 4], we have:\n *\n *    10\n *  3    7\n * 1 2  3 4\n *\n * But some nodes aren't really important. In fact every right child isn't\n * needed to compute the prefix sum (as its value is just the parent's value\n * minus the left child), so we can store the tree in a compact array structure\n * like this:\n *\n * 1 3 3 10\n *\n * Here we assume all the operations will be on a 1-based array for two\n * reasons: (1) the bit operations become rather easy and (2) it's better to\n * reason about the range sum (prefix(b) - prefix(a-1)) on a 1-based array.\n */\nfunction FenwickTree(length) {\n  this._elements = new Array(length + 1);\n  for (var i = 0; i < this._elements.length ; i++)\n    this._elements[i] = 0;\n}\n\n/**\n * Adds value to the array at specified index in O(log n)\n */\nFenwickTree.prototype.adjust = function (index, value) {\n  /*\n    This function goes up the tree adding the value to all parent nodes.\n\n    In the array, to know where a index is in the tree, just look at where is\n    the rightmost bit. 1 is a leaf, because the rightmost bit is at position 0.\n    2 (10) is 1 level above the leafs. 4 (100) is 2 levels above the leafs.\n\n    Going up the tree means pushing the rightmost bit far to the left. We do\n    this by adding only the bit itself to the index. Eventually we skip\n    some levels that aren't represented in the array. E.g. starting at 3 (11),\n    it's imediate parent is 11b + 1b = 100b. We started at a leaf  and skipped\n    the level-1 node, because it wasn't represented in the array\n    (a right child).\n\n    Note: (index&-index) finds the rightmost bit in index.\n  */\n  for (; index < this._elements.length ; index += (index&-index))\n    this._elements[index] += value;\n};\n\n/**\n* Returns the sum of all values up to specified index in O(log n)\n*/\nFenwickTree.prototype.prefixSum = function (index) {\n  /*\n    This function goes up the tree adding the required nodes to sum the prefix.\n\n    The key here is to sum every node that isn't in the same subtree as an\n    already seen node. In practice we proceed always getting a node's uncle\n    (the sibling of the node's parent). So, if we start at the index 7, we must\n    go to 6 (7's uncle), then to 4 (6's uncle), then we stop, because 4 has\n    no uncle.\n\n    Binary-wise, this is the same as erasing the rightmost bit of the index.\n    E.g. 7 (111) -> 6 (110) -> 4 (100).\n\n    Note: (index&-index) finds the rightmost bit in index.\n  */\n\n  var sum = 0;\n  for (; index > 0 ; index -= (index&-index))\n    sum += this._elements[index];\n  return sum;\n};\n\n/**\n* Returns the sum of all values between two indexes in O(log n)\n*/\nFenwickTree.prototype.rangeSum = function (fromIndex, toIndex) {\n  return this.prefixSum(toIndex) - this.prefixSum(fromIndex - 1);\n};\n\nmodule.exports = FenwickTree;\n","/home/travis/build/npmtest/node-npmtest-algorithms/node_modules/algorithms/graph.js":"'use strict';\n\n// Graph algorithms\nmodule.exports = {\n  topologicalSort: require('./algorithms/graph/topological_sort'),\n  dijkstra: require('./algorithms/graph/dijkstra'),\n  SPFA: require('./algorithms/graph/SPFA'),\n  bellmanFord: require('./algorithms/graph/bellman_ford'),\n  eulerPath: require('./algorithms/graph/euler_path'),\n  depthFirstSearch: require('./algorithms/graph/depth_first_search'),\n  kruskal: require('./algorithms/graph/kruskal'),\n  breadthFirstSearch: require('./algorithms/graph/breadth_first_search'),\n  bfsShortestPath: require('./algorithms/graph/bfs_shortest_path'),\n  prim: require('./algorithms/graph/prim'),\n  floydWarshall: require('./algorithms/graph/floyd_warshall')\n};\n","/home/travis/build/npmtest/node-npmtest-algorithms/node_modules/algorithms/algorithms/graph/topological_sort.js":"'use strict';\n\nvar Stack = require('../../data_structures/stack'),\n    depthFirstSearch = require('../../algorithms/graph/depth_first_search');\n\n/**\n * Sorts the edges of the DAG topologically\n *\n *  (node1) -> (node2) -> (node4)\n *     \\-> (node3)^\n *\n * Meaning that:\n * - \"node2\" and \"node3\" depend on \"node1\"\n * - \"node4\" depend on node2\n * - \"node2\" depend on \"node3\"\n *\n * @param {Graph}\n * @return Stack\n */\nvar topologicalSort = function (graph) {\n  var stack = new Stack();\n  var firstHit = {};\n  var time = 0;\n\n  graph.vertices.forEach(function (node) {\n    if (!firstHit[node]) {\n      depthFirstSearch(graph, node, {\n        allowTraversal: function (node, neighbor) {\n          return !firstHit[neighbor];\n        },\n        enterVertex: function (node) {\n          firstHit[node] = ++time;\n        },\n        leaveVertex: function (node) {\n          stack.push(node);\n        }\n      });\n    }\n  });\n\n  return stack;\n};\n\nmodule.exports = topologicalSort;\n","/home/travis/build/npmtest/node-npmtest-algorithms/node_modules/algorithms/algorithms/graph/depth_first_search.js":"'use strict';\n\n\n/**\n * @typedef {Object} Callbacks\n * @param {function(vertex: *, neighbor: *): boolean} allowTraversal -\n *   Determines whether DFS should traverse from the vertex to its neighbor\n *   (along the edge). By default prohibits visiting the same vertex again.\n * @param {function(vertex: *, neighbor: *)} beforeTraversal - Called before\n *   recursive DFS call.\n * @param {function(vertex: *, neighbor: *)} afterTraversal - Called after\n *   recursive DFS call.\n * @param {function(vertex: *)} enterVertex - Called when DFS enters the vertex.\n * @param {function(vertex: *)} leaveVertex - Called when DFS leaves the vertex.\n */\n\n\n/**\n * Fill in missing callbacks.\n * @param {Callbacks} callbacks\n * @param {Array} seenVertices - Vertices already discovered,\n *   used by default allowTraversal implementation.\n * @return {Callbacks} The same object or new one (if null passed).\n */\nvar normalizeCallbacks = function (callbacks, seenVertices) {\n  callbacks = callbacks || {};\n\n  callbacks.allowTraversal = callbacks.allowTraversal || (function () {\n    var seen = {};\n    seenVertices.forEach(function (vertex) {\n      seen[vertex] = true;\n    });\n\n    return function (vertex, neighbor) {\n      // It should still be possible to redefine other callbacks,\n      // so we better do all at once here.\n\n      if (!seen[neighbor]) {\n        seen[neighbor] = true;\n        return true;\n      }\n      return false;\n    };\n  })();\n\n  var noop = function () {};\n  callbacks.beforeTraversal = callbacks.beforeTraversal || noop;\n  callbacks.afterTraversal = callbacks.afterTraversal || noop;\n  callbacks.enterVertex = callbacks.enterVertex || noop;\n  callbacks.leaveVertex = callbacks.leaveVertex || noop;\n\n  return callbacks;\n};\n\n\n/**\n * Run Depth-First Search from a start vertex.\n * Complexity (default implementation): O(V + E).\n *\n * @param {Graph} graph\n * @param {*} startVertex\n * @param {Callbacks} [callbacks]\n */\nvar depthFirstSearch = function (graph, startVertex, callbacks) {\n  dfsLoop(graph, startVertex, normalizeCallbacks(callbacks, [startVertex]));\n};\n\n\nvar dfsLoop = function dfsLoop(graph, vertex, callbacks) {\n  callbacks.enterVertex(vertex);\n\n  graph.neighbors(vertex).forEach(function (neighbor) {\n    if (callbacks.allowTraversal(vertex, neighbor)) {\n      callbacks.beforeTraversal(vertex, neighbor);\n      dfsLoop(graph, neighbor, callbacks);\n      callbacks.afterTraversal(vertex, neighbor);\n    }\n  });\n\n  callbacks.leaveVertex(vertex);\n};\n\n\nmodule.exports = depthFirstSearch;\n","/home/travis/build/npmtest/node-npmtest-algorithms/node_modules/algorithms/algorithms/graph/dijkstra.js":"'use strict';\n\nvar PriorityQueue = require('../../data_structures/priority_queue');\n\n/**\n * Calculates the shortest paths in a graph to every node from the node s\n * with Dijkstra's algorithm\n *\n * @param {Object} graph An adjacency list representing the graph\n * @param {string} start the starting node\n *\n */\nfunction dijkstra(graph, s) {\n  var distance = {};\n  var previous = {};\n  var q = new PriorityQueue();\n  // Initialize\n  distance[s] = 0;\n  graph.vertices.forEach(function (v) {\n    if (v !== s) {\n      distance[v] = Infinity;\n    }\n    q.insert(v, distance[v]);\n  });\n\n  var currNode;\n  var relax = function (v) {\n    var newDistance = distance[currNode] + graph.edge(currNode, v);\n    if (newDistance < distance[v]) {\n      distance[v] = newDistance;\n      previous[v] = currNode;\n      q.changePriority(v, distance[v]);\n    }\n  };\n  while (!q.isEmpty()) {\n    currNode = q.extract();\n    graph.neighbors(currNode).forEach(relax);\n  }\n  return {\n    distance: distance,\n    previous: previous\n  };\n}\n\nmodule.exports = dijkstra;\n","/home/travis/build/npmtest/node-npmtest-algorithms/node_modules/algorithms/algorithms/graph/SPFA.js":"'use strict';\n\n/**\n * Calculates the shortest paths in a graph to every node from the node s\n * with SPFA(Shortest Path Faster Algorithm) algorithm\n *\n * @param {Object} graph An adjacency list representing the graph\n * @param {string} start the starting node\n *\n */\nfunction spfa(graph, s) {\n  var distance = {};\n  var previous = {};\n  var queue = {};\n  var isInQue = {};\n  var cnt = {};\n  var head = 0;\n  var tail = 1;\n  // initialize\n  distance[s] = 0;\n  queue[0] = s;\n  isInQue[s] = true;\n  cnt[s] = 1;\n  graph.vertices.forEach(function (v) {\n    if (v !== s) {\n      distance[v] = Infinity;\n      isInQue[v] = false;\n      cnt[v] = 0;\n    }\n  });\n\n  var currNode;\n  while (head !== tail) {\n    currNode = queue[head++];\n    isInQue[currNode] = false;\n    var neighbors = graph.neighbors(currNode);\n    for (var i = 0; i < neighbors.length; i++) {\n      var v = neighbors[i];\n      // relaxation\n      var newDistance = distance[currNode] + graph.edge(currNode, v);\n      if (newDistance < distance[v]) {\n        distance[v] = newDistance;\n        previous[v] = currNode;\n        if (!isInQue[v]) {\n          queue[tail++] = v;\n          isInQue[v] = true;\n          cnt[v]++;\n          if (cnt[v] > graph.vertices.size)\n            // indicates negative-weighted cycle\n            return {\n              distance: {}\n            };\n        }\n      }\n    }\n  }\n\n  return {\n    distance: distance,\n    previous: previous\n  };\n}\n\nmodule.exports = spfa;\n","/home/travis/build/npmtest/node-npmtest-algorithms/node_modules/algorithms/algorithms/graph/bellman_ford.js":"'use strict';\n\n/**\n * Calculates the shortest paths in a graph to every node\n * from the node 'startNode' with Bellman-Ford's algorithm\n *\n * Worst Case Complexity: O(|V| * |E|), where |V| is the number of\n * vertices and |E| is the number of edges in the graph\n *\n * @param Object 'graph' An adjacency list representing the graph\n * @param String 'startNode' The starting node\n * @return Object the minimum distance to reach every vertice of\n *    the graph starting in 'startNode', or an empty object if there\n *    exists a Negative-Weighted Cycle in the graph\n */\nvar bellmanFord = function (graph, startNode) {\n  var minDistance = {};\n  var previousVertex = {};\n  var edges = [];\n  var adjacencyListSize = 0;\n\n  // Add all the edges from the graph to the 'edges' array\n  graph.vertices.forEach(function (s) {\n    graph.neighbors(s).forEach(function (t) {\n      edges.push({\n        source: s,\n        target: t,\n        weight: graph.edge(s, t)\n      });\n    });\n\n    minDistance[s] = Infinity;\n    ++adjacencyListSize;\n  });\n\n  minDistance[startNode] = 0;\n\n  var edgesSize = edges.length;\n  var sourceDistance;\n  var targetDistance;\n\n  var iteration;\n  for (iteration = 0; iteration < adjacencyListSize; ++iteration) {\n    var somethingChanged = false;\n\n    for (var j = 0; j < edgesSize; j++) {\n      sourceDistance = minDistance[edges[j].source] + edges[j].weight;\n      targetDistance = minDistance[edges[j].target];\n\n      if (sourceDistance < targetDistance) {\n        somethingChanged = true;\n        minDistance[edges[j].target] = sourceDistance;\n        previousVertex[edges[j].target] = edges[j].source;\n      }\n    }\n\n    if (!somethingChanged) {\n      // Early stop.\n      break;\n    }\n  }\n\n  // If the loop did not break early, then there is a negative-weighted cycle.\n  if (iteration === adjacencyListSize) {\n    // Empty 'distance' object indicates Negative-Weighted Cycle\n    return {\n      distance: {}\n    };\n  }\n\n  return {\n    distance: minDistance,\n    previous: previousVertex\n  };\n};\n\nmodule.exports = bellmanFord;\n","/home/travis/build/npmtest/node-npmtest-algorithms/node_modules/algorithms/algorithms/graph/euler_path.js":"'use strict';\n\n\nvar Graph = require('../../data_structures/graph'),\n    depthFirstSearch = require('../../algorithms/graph/depth_first_search');\n\n\n/** Examine a graph and compute pair of end vertices of the existing Euler path.\n * Return pair of undefined values if there is no specific choice of end points.\n * Return value format: {start: START, finish: FINISH}.\n *\n * @param {Graph} Graph, must be connected and contain at least one vertex.\n * @return Object\n */\nvar eulerEndpoints = function (graph) {\n  var rank = {};\n  //     start     ->  rank = +1\n  // middle points ->  rank =  0\n  //    finish     ->  rank = -1\n\n  // Initialize ranks to be outdegrees of vertices.\n  graph.vertices.forEach(function (vertex) {\n    rank[vertex] = graph.neighbors(vertex).length;\n  });\n\n  if (graph.directed) {\n    // rank = outdegree - indegree\n    graph.vertices.forEach(function (vertex) {\n      graph.neighbors(vertex).forEach(function (neighbor) {\n        rank[neighbor] -= 1;\n      });\n    });\n  }\n  else {\n    // Compute ranks from vertex degree parity values.\n    var startChosen = false;\n    graph.vertices.forEach(function (vertex) {\n      rank[vertex] %= 2;\n      if (rank[vertex]) {\n        if (startChosen) {\n          rank[vertex] = -1;\n        }\n        startChosen = true;\n      }\n    });\n  }\n\n  var start, finish, v;\n\n  graph.vertices.forEach(function (vertex) {\n    if (rank[vertex] === 1) {\n      if (start) {\n        throw new Error('Duplicate start vertex.');\n      }\n      start = vertex;\n    } else if (rank[vertex] === -1) {\n      if (finish) {\n        throw new Error('Duplicate finish vertex.');\n      }\n      finish = vertex;\n    } else if (rank[vertex]) {\n      throw new Error('Unexpected vertex degree for ' + vertex);\n    } else if (!v) {\n      v = vertex;\n    }\n  });\n\n  if (!start && !finish) {\n    start = finish = v;\n  }\n\n  return {start: start,\n          finish: finish};\n};\n\n\n/**\n * Compute Euler path (either walk or tour, depending on the graph).\n * Euler path is a trail in a graph which visits every edge exactly once.\n * The procedure works both for directed and undirected graphs,\n *   although the details differ a bit.\n * The resulting array consists of exactly |E|+1 vertices.\n *\n * @param {Graph}\n * @return Array\n */\nvar eulerPath = function (graph) {\n  if (!graph.vertices.size) {\n    return [];\n  }\n\n  var endpoints = eulerEndpoints(graph);\n  var route = [endpoints.finish];\n\n  var seen = new Graph(graph.directed);\n  graph.vertices.forEach(seen.addVertex.bind(seen));\n\n  depthFirstSearch(graph, endpoints.start, {\n    allowTraversal: function (vertex, neighbor) {\n      return !seen.edge(vertex, neighbor);\n    },\n    beforeTraversal: function (vertex, neighbor) {\n      seen.addEdge(vertex, neighbor);\n    },\n    afterTraversal: function (vertex) {\n      route.push(vertex);\n    }\n  });\n\n  graph.vertices.forEach(function (vertex) {\n    if (seen.neighbors(vertex).length < graph.neighbors(vertex).length) {\n      throw new Error('There is no euler path for a disconnected graph.');\n    }\n  });\n  return route.reverse();\n};\n\n\nmodule.exports = eulerPath;\n","/home/travis/build/npmtest/node-npmtest-algorithms/node_modules/algorithms/algorithms/graph/kruskal.js":"'use strict';\n\nvar DisjointSetForest = require('../../data_structures/disjoint_set_forest'),\n    Graph = require('../../data_structures/graph');\n\n\n/**\n * Kruskal's minimum spanning tree (forest) algorithm.\n * Complexity: O(E * log(V)).\n *\n * @param {Graph} graph - Undirected graph.\n * @return {Graph} Minimum spanning tree or forest\n *   (depending on whether input graph is connected itself).\n */\nvar kruskal = function (graph) {\n  if (graph.directed) {\n    throw new Error('Can\\'t build MST of a directed graph.');\n  }\n\n  var connectedComponents = new DisjointSetForest();\n  var mst = new Graph(false);\n  graph.vertices.forEach(mst.addVertex.bind(mst));\n\n  var edges = [];\n  graph.vertices.forEach(function (vertex) {\n    graph.neighbors(vertex).forEach(function (neighbor) {\n      // Compared as strings, loops intentionally omitted.\n      if (vertex < neighbor) {\n        edges.push({\n          ends: [vertex, neighbor],\n          weight: graph.edge(vertex, neighbor)\n        });\n      }\n    });\n  });\n\n  edges.sort(function (a, b) {\n    return a.weight - b.weight;\n  }).forEach(function (edge) {\n    if (!connectedComponents.sameSubset(edge.ends[0], edge.ends[1])) {\n      mst.addEdge(edge.ends[0], edge.ends[1], edge.weight);\n      connectedComponents.merge(edge.ends[0], edge.ends[1]);\n    }\n  });\n\n  return mst;\n};\n\n\nmodule.exports = kruskal;\n","/home/travis/build/npmtest/node-npmtest-algorithms/node_modules/algorithms/algorithms/graph/breadth_first_search.js":"'use strict';\n\nvar Queue = require('../../data_structures/queue');\n\n\n/**\n * @typedef {Object} Callbacks\n * @param {function(vertex: *, neighbor: *): boolean} allowTraversal -\n *   Determines whether BFS should traverse from the vertex to its neighbor\n *   (along the edge). By default prohibits visiting the same vertex again.\n * @param {function(vertex: *, neighbor: *)} onTraversal - Called when BFS\n *   follows the edge (and puts its head into the queue).\n * @param {function(vertex: *)} enterVertex - Called when BFS enters the vertex.\n * @param {function(vertex: *)} leaveVertex - Called when BFS leaves the vertex.\n */\n\n\n/**\n * Fill in missing callbacks.\n *\n * @param {Callbacks} callbacks\n * @param {Array} seenVertices - Vertices already discovered,\n *   used by default allowTraversal implementation.\n * @return {Callbacks} The same object or new one (if null passed).\n */\nvar normalizeCallbacks = function (callbacks, seenVertices) {\n  callbacks = callbacks || {};\n\n  callbacks.allowTraversal = callbacks.allowTraversal || (function () {\n    var seen = seenVertices.reduce(function (seen, vertex) {\n      seen[vertex] = true;\n      return seen;\n    }, {});\n\n    return function (vertex, neighbor) {\n      if (!seen[neighbor]) {\n        seen[neighbor] = true;\n        return true;\n      }\n      else {\n        return false;\n      }\n    };\n  })();\n\n  var noop = function () {};\n  callbacks.onTraversal = callbacks.onTraversal || noop;\n  callbacks.enterVertex = callbacks.enterVertex || noop;\n  callbacks.leaveVertex = callbacks.leaveVertex || noop;\n\n  return callbacks;\n};\n\n\n/**\n * Run Breadth-First Search from a start vertex.\n * Complexity (default implementation): O(V + E).\n *\n * @param {Graph} graph\n * @param {*} startVertex\n * @param {Callbacks} [callbacks]\n */\nvar breadthFirstSearch = function (graph, startVertex, callbacks) {\n  var vertexQueue = new Queue();\n  vertexQueue.push(startVertex);\n  callbacks = normalizeCallbacks(callbacks, [startVertex]);\n\n  var vertex;\n  var enqueue = function (neighbor) {\n    if (callbacks.allowTraversal(vertex, neighbor)) {\n      callbacks.onTraversal(vertex, neighbor);\n      vertexQueue.push(neighbor);\n    }\n  };\n\n  while (!vertexQueue.isEmpty()) {\n    vertex = vertexQueue.pop();\n    callbacks.enterVertex(vertex);\n    graph.neighbors(vertex).forEach(enqueue);\n    callbacks.leaveVertex(vertex);\n  }\n};\n\n\nmodule.exports = breadthFirstSearch;\n","/home/travis/build/npmtest/node-npmtest-algorithms/node_modules/algorithms/algorithms/graph/bfs_shortest_path.js":"'use strict';\n\nvar breadthFirstSearch = require('./breadth_first_search');\n\n\n/**\n * Shortest-path algorithm based on Breadth-First Search.\n * Works solely on graphs with equal edge weights (but works fast).\n * Complexity: O(V + E).\n *\n * @param {Graph} graph\n * @param {string} source\n * @return {{distance: Object.<string, number>,\n *           previous: Object.<string, string>}}\n */\nvar bfsShortestPath = function (graph, source) {\n  var distance = {}, previous = {};\n  distance[source] = 0;\n\n  breadthFirstSearch(graph, source, {\n    onTraversal: function (vertex, neighbor) {\n      distance[neighbor] = distance[vertex] + 1;\n      previous[neighbor] = vertex;\n    }\n  });\n\n  return {\n    distance: distance,\n    previous: previous\n  };\n};\n\n\nmodule.exports = bfsShortestPath;\n","/home/travis/build/npmtest/node-npmtest-algorithms/node_modules/algorithms/algorithms/graph/prim.js":"'use strict';\n\nvar PriorityQueue = require('../../data_structures/priority_queue'),\n    Graph = require('../../data_structures/graph');\n\n\n/**\n * Prim's minimum spanning tree (forest) algorithm.\n * Complexity: O(E * log(V)).\n *\n * @param {Graph} graph - Undirected graph.\n * @return {Graph} Minimum spanning tree or forest\n *   (depending on whether input graph is connected itself).\n */\nvar prim = function (graph) {\n  if (graph.directed) {\n    throw new Error('Can\\'t build MST of a directed graph.');\n  }\n\n  var mst = new Graph(false);\n  var parent = Object.create(null);\n\n  var q = new PriorityQueue();\n  graph.vertices.forEach(function (vertex) {\n    q.insert(vertex, Infinity);\n  });\n\n  var relax = function (vertex, neighbor) {\n    var weight = graph.edge(vertex, neighbor);\n    if (weight < q.priority(neighbor)) {\n      q.changePriority(neighbor, weight);\n      parent[neighbor] = vertex;\n    }\n  };\n\n  while (!q.isEmpty()) {\n    var top = q.extract(true);\n    var vertex = top.item,\n        weight = top.priority;\n\n    if (parent[vertex]) {\n      mst.addEdge(parent[vertex], vertex, weight);\n    }\n    else {\n      mst.addVertex(vertex);\n    }\n\n    graph.neighbors(vertex).forEach(relax.bind(null, vertex));\n  }\n\n  return mst;\n};\n\n\nmodule.exports = prim;\n","/home/travis/build/npmtest/node-npmtest-algorithms/node_modules/algorithms/algorithms/graph/floyd_warshall.js":"'use strict';\n\n\n/**\n * Floyd-Warshall algorithm.\n * Compute all-pairs shortest paths (a path for each pair of vertices).\n * Complexity: O(V^3).\n *\n * @param {Graph} graph\n * @return {{distance, path}}\n */\nvar floydWarshall = function (graph) {\n\n  // Fill in the distances with initial values:\n  //   - 0 if source == destination;\n  //   - edge(source, destination) if there is a direct edge;\n  //   - +inf otherwise.\n  var distance = Object.create(null);\n  graph.vertices.forEach(function (src) {\n    distance[src] = Object.create(null);\n    graph.vertices.forEach(function (dest) {\n      if (src === dest) {\n        distance[src][dest] = 0;\n      } else if (graph.edge(src, dest) !== undefined) {\n        distance[src][dest] = graph.edge(src, dest);\n      } else {\n        distance[src][dest] = Infinity;\n      }\n    });\n  });\n\n  // Internal vertex with the largest index along the shortest path.\n  // Needed for path reconstruction.\n  var middleVertex = Object.create(null);\n  graph.vertices.forEach(function (vertex) {\n    middleVertex[vertex] = Object.create(null);\n  });\n\n  graph.vertices.forEach(function (middle) {\n    graph.vertices.forEach(function (src) {\n      graph.vertices.forEach(function (dest) {\n        var dist = distance[src][middle] + distance[middle][dest];\n        if (dist < distance[src][dest]) {\n          distance[src][dest] = dist;\n          middleVertex[src][dest] = middle;\n        }\n      });\n    });\n  });\n\n  // Check for a negative-weighted cycle.\n  graph.vertices.forEach(function (vertex) {\n    if (distance[vertex][vertex] < 0) {\n      // Negative-weighted cycle found.\n      throw new Error('The graph contains a negative-weighted cycle!');\n    }\n  });\n\n  /**\n   * Reconstruct the shortest path for a given pair of end vertices.\n   * Complexity: O(L), L - length of the path (number of edges).\n   *\n   * @param {string} srce\n   * @param {string} dest\n   * @return {?string[]} Null if destination is unreachable.\n   */\n  var path = function (src, dest) {\n    if (!Number.isFinite(distance[src][dest])) {\n      // dest unreachable.\n      return null;\n    }\n\n    var path = [src];\n\n    if (src !== dest) {\n      (function pushInOrder(src, dest) {\n        if (middleVertex[src][dest] === undefined) {\n          path.push(dest);\n        } else {\n          var middle = middleVertex[src][dest];\n          pushInOrder(src, middle);\n          pushInOrder(middle, dest);\n        }\n      })(src, dest);\n    }\n\n    return path;\n  };\n\n  return {\n    distance: distance,\n    path: path\n  };\n};\n\n\nmodule.exports = floydWarshall;\n","/home/travis/build/npmtest/node-npmtest-algorithms/node_modules/algorithms/geometry.js":"'use strict';\n\n// Geometry algorithms\nmodule.exports = {\n  BezierCurve: require('./algorithms/geometry/bezier_curve')\n};\n","/home/travis/build/npmtest/node-npmtest-algorithms/node_modules/algorithms/algorithms/geometry/bezier_curve.js":"'use strict';\n\n/**\n * 2D bezier-curve, https://en.wikipedia.org/wiki/B%C3%A9zier_curve\n * Usage:\n *   var b = new BezierCurve([{x: 0, y: 0}, {x: 10, y: 3}]);\n *   b.get(0.5); // {x: 5, y: 1.5}\n */\n\n/**\n * Generates a bezier-curve from a series of points\n * @param Array array of control points ([{x: x0, y: y0}, {x: x1, y: y1}])\n */\nvar BezierCurve = function (points) {\n  this.n = points.length;\n  this.p = [];\n\n  // The binomial coefficient\n  var c = [1];\n  var i, j;\n  for (i = 1; i < this.n; ++i) {\n    c.push(0);\n    for (j = i; j >= 1; --j) {\n        c[j] += c[j - 1];\n    }\n  }\n\n  // the i-th control point times the coefficient\n  for (i = 0; i < this.n; ++i) {\n    this.p.push({x: c[i] * points[i].x, y: c[i] * points[i].y});\n  }\n};\n\n/**\n * @param Number float variable from 0 to 1\n */\nBezierCurve.prototype.get = function (t) {\n  var res = {x: 0, y: 0};\n  var i;\n  var a = 1, b = 1;\n\n  // The coefficient\n  var c = [];\n  for (i = 0; i < this.n; ++i) {\n    c.push(a);\n    a *= t;\n  }\n\n  for (i = this.n - 1; i >= 0; --i) {\n    res.x += this.p[i].x * c[i] * b;\n    res.y += this.p[i].y * c[i] * b;\n    b *= 1 - t;\n  }\n  return res;\n};\n\nmodule.exports = BezierCurve;\n","/home/travis/build/npmtest/node-npmtest-algorithms/node_modules/algorithms/math.js":"'use strict';\n\n// Math algorithms\nmodule.exports = {\n  fibonacci: require('./algorithms/math/fibonacci'),\n  fisherYates: require('./algorithms/math/fisher_yates'),\n  gcd: require('./algorithms/math/gcd'),\n  extendedEuclidean: require('./algorithms/math/extended_euclidean'),\n  lcm: require('./algorithms/math/lcm'),\n  newtonSqrt: require('./algorithms/math/newton_sqrt'),\n  primalityTests: require('./algorithms/math/primality_tests'),\n  reservoirSampling: require('./algorithms/math/reservoir_sampling'),\n  fastPower: require('./algorithms/math/fast_power'),\n  nextPermutation: require('./algorithms/math/next_permutation'),\n  powerSet: require('./algorithms/math/power_set'),\n  shannonEntropy: require('./algorithms/math/shannon_entropy'),\n  collatzConjecture: require('./algorithms/math/collatz_conjecture'),\n  greatestDifference: require('./algorithms/math/greatest_difference')\n};\n","/home/travis/build/npmtest/node-npmtest-algorithms/node_modules/algorithms/algorithms/math/fibonacci.js":"'use strict';\n\n/**\n * Different implementations of the Fibonacci sequence\n */\n\nvar power = require('./fast_power');\n\n/**\n  * Regular fibonacci implementation following the definition:\n  * Fib(0) = 0\n  * Fib(1) = 1\n  * Fib(n) = Fib(n-1) + Fib(n-2)\n  *\n  * @param Number\n  * @return Number\n  */\nvar fibExponential = function (n) {\n  return n < 2 ? n : fibExponential(n - 1) + fibExponential(n - 2);\n};\n\n/**\n  * O(n) in time, O(1) in space and doesn't use recursion\n  *\n  * @param Number\n  * @return Number\n  */\nvar fibLinear = function (n) {\n  var fibNMinus2 = 0,\n      fibNMinus1 = 1,\n      fib = n;\n  for (var i = 1; i < n; i++) {\n    fib = fibNMinus1 + fibNMinus2;\n    fibNMinus2 = fibNMinus1;\n    fibNMinus1 = fib;\n  }\n  return fib;\n};\n\n/**\n  * Implementation with memoization, O(n) in time, O(n) in space\n  *\n  * @param Number\n  * @return Number\n  */\nvar fibWithMemoization = (function () {\n  var cache = [0, 1];\n\n  var fib = function (n) {\n    if (cache[n] === undefined) {\n      cache[n] = fib(n - 1) + fib(n - 2);\n    }\n    return cache[n];\n  };\n\n  return fib;\n})();\n\n/**\n  * Implementation using Binet's formula with the rounding trick.\n  * O(1) in time, O(1) in space\n  *\n  * @param Number\n  * @return Number\n  */\nvar fibDirect = function (number) {\n  var phi = (1 + Math.sqrt(5)) / 2;\n  return Math.floor(Math.pow(phi, number) / Math.sqrt(5) + 0.5);\n};\n\n/**\n  * Implementation based on matrix exponentiation.\n  * O(log(n)) in time, O(1) in space\n  *\n  * @param Number\n  * @return Number\n  */\nvar fibLogarithmic = function (number) {\n  // Transforms [f_1, f_0] to [f_2, f_1] and so on.\n  var nextFib = [[1, 1], [1, 0]];\n\n  var matrixMultiply = function (a, b) {\n    return [[a[0][0] * b[0][0] + a[0][1] * b[1][0],\n             a[0][0] * b[0][1] + a[0][1] * b[1][1]],\n            [a[1][0] * b[0][0] + a[1][1] * b[1][0],\n             a[1][0] * b[0][1] + a[1][1] * b[1][1]]];\n  };\n\n  var transform = power(nextFib, number, matrixMultiply, [[1, 0], [0, 1]]);\n\n  // [f_n, f_{n-1}] = Transform * [f_0, f_{-1}] = Transform * [0, 1]\n  // Hence the result is the first row of Transform multiplied by [0, 1],\n  // which is the same as transform[0][1].\n  return transform[0][1];\n};\n\n// Use fibLinear as the default implementation\nfibLinear.exponential = fibExponential;\nfibLinear.withMemoization = fibWithMemoization;\nfibLinear.direct = fibDirect;\nfibLinear.logarithmic = fibLogarithmic;\nmodule.exports = fibLinear;\n","/home/travis/build/npmtest/node-npmtest-algorithms/node_modules/algorithms/algorithms/math/fast_power.js":"'use strict';\n\n\nvar multiplicationOperator = function (a, b) {\n  return a * b;\n};\n\n\n/**\n * Raise value to a positive integer power by repeated squaring.\n *\n * @param {*} base\n * @param {number} power\n * @param {function} [mul] - Multiplication function,\n *   standard multiplication operator by default.\n * @param {*} identity - Identity value, used when power == 0.\n *   If mul is not set, defaults to 1.\n * @return {*}\n */\nvar fastPower = function (base, power, mul, identity) {\n  if (mul === undefined) {\n    mul = multiplicationOperator;\n    identity = 1;\n  }\n  if (power < 0 || Math.floor(power) !== power) {\n    throw new Error('Power must be a positive integer or zero.');\n  }\n\n  // If the power is zero, identity value must be given (or set by default).\n  if (!power) {\n    if (identity === undefined) {\n      throw new Error('The power is zero, but identity value not set.');\n    }\n    else {\n      return identity;\n    }\n  }\n\n  // Iterative form of the algorithm avoids checking the same thing twice.\n  var result;\n  var multiplyBy = function (value) {\n    result = (result === undefined) ? value : mul(result, value);\n  };\n  for (var factor = base; power; power >>>= 1, factor = mul(factor, factor)) {\n    if (power & 1) {\n      multiplyBy(factor);\n    }\n  }\n  return result;\n};\n\n\nmodule.exports = fastPower;\n","/home/travis/build/npmtest/node-npmtest-algorithms/node_modules/algorithms/algorithms/math/fisher_yates.js":"'use strict';\n\n/**\n * Fisher-Yates shuffles the elements in an array\n * in O(n)\n */\nvar fisherYates = function (a) {\n  for (var i = a.length - 1; i > 0; i--) {\n    var j = Math.floor(Math.random() * (i + 1));\n    var tmp = a[i];\n    a[i] = a[j];\n    a[j] = tmp;\n  }\n};\n\nmodule.exports = fisherYates;\n","/home/travis/build/npmtest/node-npmtest-algorithms/node_modules/algorithms/algorithms/math/gcd.js":"'use strict';\n\n/**\n * Euclidean algorithm to calculate the Greatest Common Divisor (GCD)\n *\n * @param Number\n * @param Number\n *\n * @return Number\n */\nvar gcdDivisionBased = function (a, b) {\n  var tmp = a;\n  a = Math.max(a, b);\n  b = Math.min(tmp, b);\n  while (b !== 0) {\n    tmp = b;\n    b = a % b;\n    a = tmp;\n  }\n\n  return a;\n};\n\n/**\n * Binary GCD algorithm (Stein's Algorithm)\n *\n * @link https://en.wikipedia.org/wiki/Binary_GCD_algorithm\n * This is basically a js version of the c implementation on Wikipedia\n *\n * @param Number\n * @param Number\n *\n * @return Number\n */\nvar gcdBinaryIterative = function (a, b) {\n\n  // GCD(0,b) == b; GCD(a,0) == a, GCD(0,0) == 0\n  if (a === 0) {\n    return b;\n  }\n\n  if (b === 0) {\n    return a;\n  }\n\n  var shift;\n  // Let shift = log(K), where K is the greatest power of 2\n  // dividing both a and b\n  for (shift = 0; ((a | b) & 1) === 0; ++shift) {\n    a >>= 1;\n    b >>= 1;\n  }\n\n  // Remove all factors of 2 in a -- they are not common\n  // Note: a is not zero, so while will terminate\n  while ((a & 1) === 0) {\n    a >>= 1;\n  }\n\n  var tmp;\n\n  // From here on, a is always odd\n  do {\n    // Remove all factors of 2 in b -- they are not common\n    // Note: b is not zero, so while will terminate\n    while ((b & 1) === 0) {\n      b >>= 1;\n    }\n\n    // Now a and b are both odd. Swap if necessary so a <= b,\n    // then set b = b - a (which is even).\n    if (a > b) {\n      tmp = b;\n      b = a;\n      a = tmp;\n    }\n\n    b -= a;  // Here b >= a\n  } while (b !== 0);\n\n  // restore common factors of 2\n  return a << shift;\n};\n\ngcdDivisionBased.binary = gcdBinaryIterative;\nmodule.exports = gcdDivisionBased;\n","/home/travis/build/npmtest/node-npmtest-algorithms/node_modules/algorithms/algorithms/math/extended_euclidean.js":"'use strict';\n\n/**\n * Extended Euclidean algorithm to calculate the solve of\n *   ax + by = gcd(a, b)\n * gcd(a, b) is the greatest common divisor of integers a and b.\n *\n * @param Number\n * @param Number\n *\n * @return {Number, Number}\n */\nvar extEuclid = function (a, b) {\n  var s = 0, oldS = 1;\n  var t = 1, oldT = 0;\n  var r = b, oldR = a;\n  var quotient, temp;\n  while (r !== 0) {\n    quotient = Math.floor(oldR / r);\n\n    temp = r;\n    r = oldR - quotient * r;\n    oldR = temp;\n\n    temp = s;\n    s = oldS - quotient * s;\n    oldS = temp;\n\n    temp = t;\n    t = oldT - quotient * t;\n    oldT = temp;\n  }\n\n  return {\n    x: oldS,\n    y: oldT\n  };\n};\n\nmodule.exports = extEuclid;\n","/home/travis/build/npmtest/node-npmtest-algorithms/node_modules/algorithms/algorithms/math/lcm.js":"'use strict';\n\nvar gcd = require('./gcd.js');\n\n/**\n * Calcule the Least Common Multiple with a given Greatest Common Denominator\n * function\n *\n * @param Number\n * @param Number\n * @param Function\n *\n * @return Number\n */\nvar genericLCM = function (gcdFunction, a, b) {\n   if (a === 0 || b === 0) {\n    return 0;\n  }\n  a = Math.abs(a);\n  b = Math.abs(b);\n  return a / gcdFunction(a, b) * b;\n};\n\n/**\n * Algorithm to calculate Least Common Multiple based on Euclidean algorithm\n * calls the generic LCM function passing the division based GCD calculator\n *\n * @param Number\n * @param Number\n *\n * @return Number\n */\nvar lcmDivisionBased = genericLCM.bind(null, gcd);\n\n/**\n * Algorithm to calculate Least Common Multiple based on Stein's Algorithm\n * calls the generic LCM function passing the binary interative GCD calculator\n *\n * @param Number\n * @param Number\n *\n * @return Number\n */\nvar lcmBinaryIterative = genericLCM.bind(null, gcd.binary);\n\nvar lcm = lcmDivisionBased;\nlcm.binary = lcmBinaryIterative;\nmodule.exports = lcm;\n","/home/travis/build/npmtest/node-npmtest-algorithms/node_modules/algorithms/algorithms/math/newton_sqrt.js":"'use strict';\n\n/**\n * Newton's method to calculate square root\n *\n * @param Number n - the number which the square root should be calculated\n * @param Number tolerance - The error margin accepted (Default 1e-7)\n * @param Number maxIterations - The max number of iterations (Default 1e7)\n */\nvar sqrt = function (n, tolerance, maxIterations) {\n  tolerance = tolerance || 1e-7;\n  maxIterations = maxIterations || 1e7;\n\n  var upperBound = n;\n  var lowerBound = 0;\n\n  var i = 0;\n  var square, x;\n  do {\n    i++;\n    x = (upperBound - lowerBound) / 2 + lowerBound;\n    square = x * x;\n    if (square < n) lowerBound = x;\n    else upperBound = x;\n  } while (Math.abs(square - n) > tolerance && i < maxIterations);\n\n  // Checks if the number is a perfect square to return the exact root\n  var roundX = Math.round(x);\n  if (roundX * roundX === n) x = roundX;\n\n  return x;\n};\n\nmodule.exports = sqrt;\n","/home/travis/build/npmtest/node-npmtest-algorithms/node_modules/algorithms/algorithms/math/primality_tests.js":"'use strict';\n\n/**\n* Checks whether a number is prime using a given primality test\n*\n* @param Function\n* @param Number\n*\n* @return Boolean\n*/\nvar genericPrimalityTest = function (primalityTest, n) {\n  if (n <= 1) {\n    return false;\n  }\n  return primalityTest(n);\n};\n\n/**\n* Checks whether a number is prime using the naive algorithm O(n)\n*\n* @param Number\n*\n* @return Boolean\n*/\nvar naiveTest = function (n) {\n  for (var i = 2; i < n; ++i) {\n    if (n % i === 0) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n* Checks whether a number is prime using the trial divison algorithm O(sqrt(n))\n*\n* @param Number\n*\n* @return Boolean\n*/\nvar trialDivisionTest = function (n) {\n  var sqrt = Math.sqrt(n);\n  for (var i = 2; i <= sqrt; ++i) {\n    if (n % i === 0) {\n      return false;\n    }\n  }\n  return true;\n};\n\nmodule.exports = {\n  naiveTest: genericPrimalityTest.bind(null, naiveTest),\n  trialDivisionTest: genericPrimalityTest.bind(null, trialDivisionTest)\n};\n","/home/travis/build/npmtest/node-npmtest-algorithms/node_modules/algorithms/algorithms/math/reservoir_sampling.js":"'use strict';\n\n\n/**\n * Sample random elements from the array using reservoir algorithm.\n *\n * @param {Array} array\n * @param {number} sampleSize\n * @return {Array}\n */\nvar reservoirSampling = function (array, sampleSize) {\n  if (sampleSize > array.length) {\n    throw new Error('Sample size exceeds the total number of elements.');\n  }\n  var reservoir = array.slice(0, sampleSize);\n  for (var i = sampleSize; i < array.length; ++i) {\n    var j = Math.floor(Math.random() * (i + 1));\n    if (j < sampleSize) {\n      reservoir[j] = array[i];\n    }\n  }\n  return reservoir;\n};\n\n\nmodule.exports = reservoirSampling;\n","/home/travis/build/npmtest/node-npmtest-algorithms/node_modules/algorithms/algorithms/math/next_permutation.js":"'use strict';\n\nvar Comparator = require('../../util/comparator');\n\n\n/**\n * Narayana's algorithm computes the subsequent permutation\n *   in lexicographical order.\n * Complexity: O(n).\n *\n * @param {Array} array\n * @param {function} [compareFn] - Custom compare function.\n * @return {boolean} Boolean flag indicating whether the algorithm succeeded,\n *   true unless the input permutation is lexicographically the last one.\n */\nvar nextPermutation = function (array, compareFn) {\n  if (!array.length) {\n    return false;\n  }\n  var cmp = new Comparator(compareFn);\n\n  // Find pivot and successor indices.\n  var pivot = array.length - 1;\n  while (pivot && cmp.greaterThanOrEqual(array[pivot - 1], array[pivot])) {\n    pivot -= 1;\n  }\n  if (!pivot) {\n    // Permutation is sorted in descending order.\n    return false;\n  }\n  var pivotValue = array[--pivot];\n  var successor = array.length - 1;\n  while (cmp.lessThanOrEqual(array[successor], pivotValue)) {\n    successor -= 1;\n  }\n\n  // Swap values.\n  array[pivot] = array[successor];\n  array[successor] = pivotValue;\n\n  // Reverse the descending part.\n  for (var left = pivot, right = array.length; ++left < --right;) {\n    var temp = array[left];\n    array[left] = array[right];\n    array[right] = temp;\n  }\n  return true;\n};\n\n\nmodule.exports = nextPermutation;\n","/home/travis/build/npmtest/node-npmtest-algorithms/node_modules/algorithms/algorithms/math/power_set.js":"/**\n * Iterative and recursive implementations of power set\n */\n\n'use strict';\n\n/**\n * Iterative power set calculation\n */\nvar powerSetIterative = function (array) {\n\n  if (array.length === 0) {\n    return [];\n  }\n\n  var powerSet = [];\n  var cache = [];\n  var i;\n\n  for (i = 0; i < array.length; i++) {\n    cache[i] = true;\n  }\n\n  for (i = 0; i < Math.pow(2, array.length); i++) {\n\n    powerSet.push([]);\n\n    for (var j = 0; j < array.length; j++) {\n\n      if (i % Math.pow(2, j) === 0) {\n        cache[j] = !cache[j];\n      }\n\n      if (cache[j]) {\n        powerSet[i].push(array[j]);\n      }\n\n    }\n  }\n\n  return powerSet;\n};\n\n/**\n * Recursive power set calculation\n */\nvar powerSetRecursive = function (array) {\n  if (array.length === 0) {\n    return [];\n  } else if (array.length === 1) {\n    return [ [], [ array[0] ] ];\n  } else {\n    var powerSet = [];\n    var firstElem = array[0];\n\n    array.splice(0, 1);\n\n    powerSetRecursive(array).forEach(function (elem) {\n      powerSet.push(elem);\n      var withFirstElem = [ firstElem ];\n      withFirstElem.push.apply(withFirstElem, elem);\n      powerSet.push(withFirstElem);\n    });\n\n    return powerSet;\n  }\n};\n\n// Use powerSetIterative as the default implementation\nvar powerSet = powerSetIterative;\npowerSet.recursive = powerSetRecursive;\nmodule.exports = powerSet;\n","/home/travis/build/npmtest/node-npmtest-algorithms/node_modules/algorithms/algorithms/math/shannon_entropy.js":"'use strict';\n\n/**\n * Calculate Shannon Entropy of an array\n *\n * @param {Array} arr - An array of values.\n * @return Number\n */\nvar shannonEntropy = function (arr) {\n  // find the frequency of each value\n  var freqs = arr.reduce(function (acc, item) {\n    acc[item] = acc[item] + 1 || 1;\n    return acc;\n  }, {});\n\n  // find the probability of each value\n  var probs = Object.keys(freqs).map(function (key) {\n    return freqs[key] / arr.length;\n  });\n\n  // calulate the shannon entropy of the array\n  return probs.reduce(function (e, p) {\n    return e - p * Math.log(p);\n  }, 0) * Math.LOG2E;\n};\n\nmodule.exports = shannonEntropy;\n","/home/travis/build/npmtest/node-npmtest-algorithms/node_modules/algorithms/algorithms/math/collatz_conjecture.js":"'use strict';\n\n// cache algorithm results\nvar cache = {1: 1};\n\n/**\n * Collatz Conjecture algorithm\n *\n * @param Number\n * @return Number\n */\n\nfunction calculateCollatzConjecture(number) {\n  if (number in cache) return cache[number];\n  if (number % 2 === 0) return cache[number] = number >> 1;\n\n  return cache[number] = number * 3 + 1;\n}\n\n/**\n * Generate Collatz Conjecture\n *\n * @param Number\n * @return Array\n */\n\nfunction generateCollatzConjecture(number) {\n  var collatzConjecture = [];\n\n  do {\n    number = calculateCollatzConjecture(number);\n    collatzConjecture.push(number);\n  } while (number !== 1);\n\n  return collatzConjecture;\n}\n\n// export Collatz Conjecture methods\nmodule.exports = {\n  generate: generateCollatzConjecture,\n  calculate: calculateCollatzConjecture,\n};\n","/home/travis/build/npmtest/node-npmtest-algorithms/node_modules/algorithms/algorithms/math/greatest_difference.js":"'use strict';\n\n/**\n * Find the greatest difference between two numbers in a set\n * This solution has a cost of O(n)\n *\n * @param {number[]} numbers\n * @returns {number}\n */\n\nvar greatestDifference = function (numbers) {\n  var index = 0;\n  var largest = numbers[0];\n  var length = numbers.length;\n  var number;\n  var smallest = numbers[0];\n\n  for (index; index < length; index++) {\n    number = numbers[index];\n\n    if (number > largest) largest = number;\n    if (number < smallest) smallest = number;\n  }\n\n  return largest - smallest;\n};\n\nmodule.exports = greatestDifference;\n","/home/travis/build/npmtest/node-npmtest-algorithms/node_modules/algorithms/search.js":"'use strict';\n\n// Search algorithms\nmodule.exports = {\n  bfs: require('./algorithms/search/bfs'),\n  binarySearch: require('./algorithms/search/binarysearch'),\n  ternarySearch: require('./algorithms/search/ternary_search'),\n  dfs: require('./algorithms/search/dfs')\n};\n","/home/travis/build/npmtest/node-npmtest-algorithms/node_modules/algorithms/algorithms/search/bfs.js":"'use strict';\nvar Queue = require('../../data_structures/queue.js');\n\n/**\n * Breadth-first search for binary trees\n */\nvar bfs = function (root, callback) {\n  var q = new Queue();\n  q.push(root);\n  var node;\n  while (!q.isEmpty()) {\n    node = q.pop();\n    callback(node.value);\n    if (node.left) q.push(node.left);\n    if (node.right) q.push(node.right);\n  }\n};\n\nmodule.exports = bfs;\n","/home/travis/build/npmtest/node-npmtest-algorithms/node_modules/algorithms/algorithms/search/binarysearch.js":"'use strict';\n\n/**\n  * Binary Search finds elements in sorted arrays in logarithmic\n  * time (O(lg n))\n  *\n  * @param Array\n  * @param Number|String\n  *\n  * @return Boolean\n  */\nvar binarySearch = function (sortedArray, element) {\n  var init = 0,\n      end = sortedArray.length - 1;\n\n  while (end >= init) {\n    var m = ((end - init) >> 1) + init;\n    if (sortedArray[m] === element) return m;\n\n    if (sortedArray[m] < element) init = m + 1;\n    else end = m - 1;\n  }\n\n  return -1;\n};\n\nmodule.exports = binarySearch;\n","/home/travis/build/npmtest/node-npmtest-algorithms/node_modules/algorithms/algorithms/search/ternary_search.js":"'use strict';\n\n/**\n  *  Finds the maximum of unimodal function fn() within [left, right]\n  *  To find the minimum, revert the if/else statement or revert the comparison.\n  *  Time complexity: O(log(n))\n  */\n\nvar ternarySearch = function (fn, left, right, precision) {\n  while (Math.abs(right - left) > precision) {\n    var leftThird = left + (right - left) / 3,\n        rightThird = right - (right - left) / 3;\n\n    if (fn(leftThird) < fn(rightThird))\n      left = leftThird; else\n      right = rightThird;\n  }\n  return (left + right) / 2;\n};\n\nmodule.exports = ternarySearch;\n","/home/travis/build/npmtest/node-npmtest-algorithms/node_modules/algorithms/algorithms/search/dfs.js":"'use strict';\n\n/**\n * Depth first search for trees\n * (in order)\n */\nvar inOrder = function (node, callback) {\n  if (node) {\n    inOrder(node.left, callback);\n    callback(node.value);\n    inOrder(node.right, callback);\n  }\n};\n\n/**\n * Pre order\n */\nvar preOrder = function (node, callback) {\n  if (node) {\n    callback(node.value);\n    preOrder(node.left, callback);\n    preOrder(node.right, callback);\n  }\n};\n\n/**\n * Post order\n */\nvar postOrder = function (node, callback) {\n  if (node) {\n    postOrder(node.left, callback);\n    postOrder(node.right, callback);\n    callback(node.value);\n  }\n};\n\n// Set inOrder as the default implementation\ninOrder.preOrder = preOrder;\ninOrder.postOrder = postOrder;\nmodule.exports = inOrder;\n","/home/travis/build/npmtest/node-npmtest-algorithms/node_modules/algorithms/sorting.js":"'use strict';\n\n// Sorting algorithms\nmodule.exports = {\n  bubbleSort: require('./algorithms/sorting/bubble_sort'),\n  shortBubbleSort: require('./algorithms/sorting/short_bubble_sort'),\n  countingSort: require('./algorithms/sorting/counting_sort'),\n  heapSort: require('./algorithms/sorting/heap_sort'),\n  mergeSort: require('./algorithms/sorting/merge_sort'),\n  quicksort: require('./algorithms/sorting/quicksort'),\n  selectionSort: require('./algorithms/sorting/selection_sort'),\n  radixSort: require('./algorithms/sorting/radix_sort'),\n  insertionSort: require('./algorithms/sorting/insertion_sort'),\n  shellSort: require('./algorithms/sorting/shell_sort')\n};\n","/home/travis/build/npmtest/node-npmtest-algorithms/node_modules/algorithms/algorithms/sorting/bubble_sort.js":"'use strict';\nvar Comparator = require('../../util/comparator');\n\n/**\n * Bubble sort algorithm O(n^2)\n */\nvar bubbleSort = function (a, comparatorFn) {\n  var comparator = new Comparator(comparatorFn);\n  var n = a.length;\n  var bound = n - 1;\n  var check = false;\n  for (var i = 0; i < n - 1; i++) {\n    var newbound = 0;\n    for (var j = 0; j < bound; j++) {\n      if (comparator.greaterThan(a[j], a[j + 1])) {\n        var tmp = a[j];\n        a[j] = a[j + 1];\n        a[j + 1] = tmp;\n        newbound = j;\n        check = true;\n      }\n    }\n    if (!check)\n      return a;\n    bound = newbound;\n  }\n  return a;\n};\n\nmodule.exports = bubbleSort;\n","/home/travis/build/npmtest/node-npmtest-algorithms/node_modules/algorithms/algorithms/sorting/short_bubble_sort.js":"'use strict';\n\nvar Comparator = require('../../util/comparator');\n\n/**\n * short bubble sort algorithm\n * worst: O(n^2) best: O(n)\n */\n\nfunction shortBubbleSort(array, comparatorFn) {\n  var comparator = new Comparator(comparatorFn);\n  var length = array.length - 1;\n  var i = 0;\n\n  for (i; i < length; i++) {\n    var current = array[i];\n    var next = array[i+1];\n\n    /**\n     * If the current value if greater than the next:\n     * - set current value to next value;\n     * - and set next value to current value;\n     * - then reset iterator counter to rescan for values to be sorted.\n     */\n\n    if (comparator.greaterThan(current, next)) {\n      array[i+1] = current;\n      array[i] = next;\n      i = -1;\n    }\n  }\n\n  return array;\n}\n\nmodule.exports = shortBubbleSort;\n","/home/travis/build/npmtest/node-npmtest-algorithms/node_modules/algorithms/algorithms/sorting/counting_sort.js":"'use strict';\n\n/**\n * Sorts an array of objects according to their 'key' property\n * Every object inside the array MUST have the 'key' property with\n * a integer value.\n *\n * Execution Time: (3 * array.length - 1)\n * Asymptotic Complexity: O(array.length + maximumKey)\n *\n * @param Array\n * @return Array\n */\nvar countingSort = function (array) {\n  var max = maximumKey(array);\n  var auxiliaryArray = [];\n  var length = array.length;\n  var i;\n\n  for (i = 0; i < length; i++) {\n    var position = array[i].key;\n\n    if (auxiliaryArray[position] === undefined) {\n      auxiliaryArray[position] = [];\n    }\n\n    auxiliaryArray[position].push(array[i]);\n  }\n\n  array = [];\n  var pointer = 0;\n\n  for (i = 0; i <= max; i++) {\n    if (auxiliaryArray[i] !== undefined) {\n      var localLength = auxiliaryArray[i].length;\n\n      for (var j = 0; j < localLength; j++) {\n        array[pointer++] = auxiliaryArray[i][j];\n      }\n    }\n  }\n\n  return array;\n};\n\n/**\n * Finds the maximum key from an array of objects\n *\n * Asymptotic Complexity: O(array.length)\n *\n * @param Array\n * @return Integer\n */\nvar maximumKey = function (array) {\n  var max = array[0].key;\n  var length = array.length;\n\n  for (var i = 1; i < length; i++) {\n    if (array[i].key > max) {\n      max = array[i].key;\n    }\n  }\n\n  return max;\n};\n\nmodule.exports = countingSort;\n","/home/travis/build/npmtest/node-npmtest-algorithms/node_modules/algorithms/algorithms/sorting/heap_sort.js":"'use strict';\nvar MinHeap = require('../../data_structures/heap').MinHeap;\n\n/**\n * Heap sort first creates a valid heap data structure. Next it\n * iteratively removes the smallest element of the heap until it's\n * empty. The time complexity of the algorithm is O(n.lg n)\n */\nvar heapsort = function (array, comparatorFn) {\n\n  var minHeap = new MinHeap(comparatorFn);\n  minHeap.heapify(array);\n\n  var result = [];\n  while (!minHeap.isEmpty())\n    result.push(minHeap.extract());\n\n  return result;\n};\n\nmodule.exports = heapsort;\n","/home/travis/build/npmtest/node-npmtest-algorithms/node_modules/algorithms/algorithms/sorting/merge_sort.js":"'use strict';\nvar Comparator = require('../../util/comparator');\n\n/**\n * Merge sort\n * O(n.lgn)\n */\nvar mergeSortInit = function (a, compareFn) {\n  var comparator = new Comparator(compareFn);\n\n  return (function mergeSort(a) {\n    if (a.length > 1) {\n      var middle = a.length >> 1;\n      var left = mergeSort(a.slice(0, middle));\n      var right = mergeSort(a.slice(middle));\n      a = merge(left, right, comparator);\n    }\n\n    return a;\n  })(a);\n};\n\nvar merge = function (a, b, comparator) {\n  var i = 0,\n      j = 0,\n      result = [];\n\n  while (i < a.length && j < b.length) {\n    result.push(comparator.lessThan(a[i], b[j]) ? a[i++] : b[j++]);\n  }\n\n  // Concats the elements from the sub-array\n  // that has not been included yet\n  return result.concat((i < a.length ? a.slice(i) : b.slice(j)));\n};\n\nmodule.exports = mergeSortInit;\n","/home/travis/build/npmtest/node-npmtest-algorithms/node_modules/algorithms/algorithms/sorting/quicksort.js":"'use strict';\nvar Comparator = require('../../util/comparator');\n\n/**\n * Quicksort recursively sorts parts of the array in\n * O(n.lg n)\n */\nvar quicksortInit = function (array, comparatorFn) {\n\n  var comparator = new Comparator(comparatorFn);\n\n  return (function quicksort(array, lo, hi) {\n    while (lo < hi) {\n      var p = partition(array, comparator, lo, hi);\n      //Chooses only the smallest partition to use recursion on and\n      //tail-optimize the other. This guarantees O(log n) space in worst case.\n      if (p - lo < hi - p) {\n        quicksort(array, lo, p - 1);\n        lo = p + 1;\n      } else {\n        quicksort(array, p + 1, hi);\n        hi = p - 1;\n      }\n    }\n\n    return array;\n  })(array, 0, array.length - 1);\n};\n\n/**\n * Chooses a pivot and makes every element that is\n * lower than the pivot move to its left, and every\n * greater element moves to its right\n *\n * @return Number the positon of the pivot\n */\nvar partition = function (a, comparator, lo, hi) {\n  // pick a random element, swap with the rightmost and\n  // use it as pivot\n  swap(a, Math.floor(Math.random() * (hi - lo)) + lo, hi);\n  var pivot = hi;\n\n  // dividerPosition keeps track of the position\n  // where the pivot should be inserted\n  var dividerPosition = lo;\n\n  for (var i = lo; i < hi; i++) {\n    if (comparator.lessThan(a[i], a[pivot])) {\n      swap(a, i, dividerPosition);\n      dividerPosition++;\n    }\n  }\n  swap(a, dividerPosition, pivot);\n  return dividerPosition;\n};\n\n/**\n * Swaps two elements in the array\n */\nvar swap = function (array, x, y) {\n  var tmp = array[y];\n  array[y] = array[x];\n  array[x] = tmp;\n};\n\nmodule.exports = quicksortInit;\n","/home/travis/build/npmtest/node-npmtest-algorithms/node_modules/algorithms/algorithms/sorting/selection_sort.js":"'use strict';\nvar Comparator = require('../../util/comparator');\n/**\n * Selection sort algorithm O(n^2)\n */\nvar selectionSort = function (a, comparatorFn) {\n  var comparator = new Comparator(comparatorFn);\n  var n = a.length;\n  for (var i = 0; i < n - 1; i++) {\n    var min = i;\n    for (var j = i + 1; j < n; j++) {\n      if (comparator.greaterThan(a[min], a[j])) {\n        min = j;\n      }\n    }\n    if (min !== i) {\n      var tmp = a[i];\n      a[i] = a[min];\n      a[min] = tmp;\n    }\n  }\n\n  return a;\n};\n\nmodule.exports = selectionSort;\n","/home/travis/build/npmtest/node-npmtest-algorithms/node_modules/algorithms/algorithms/sorting/radix_sort.js":"'use strict';\n\n/**\n * Sorts an array of objects according to their 'key' property\n * Every object inside the array MUST have the 'key' property with\n * a integer value.\n *\n * Asymptotic Complexity: O(array.length * d), where 'd' represents\n * the amount of digits in the larger key of the array\n *\n * @param Array\n * @return Array\n */\nvar radixSort = function (array) {\n  var max = maximumKey(array);\n  var digitsMax = (max === 0 ? 1 :\n    1 + Math.floor(Math.log(max) / Math.log(10))); // log base 10\n\n  for (var i = 0; i < digitsMax; i++) {\n    array = auxiliaryCountingSort(array, i);\n  }\n\n  return array;\n};\n\n/**\n * Auxiliary sorting method for RadixSort\n * Sorts an array of objects according to only one digit of\n * their 'key' property. The digit to be sorted is determined\n * by the 'mod' variable\n * Every object inside the array MUST have the 'key' property with\n * a integer value.\n *\n * Execution Time: (2 * array.length + 10)\n * Asymptotic Complexity: O(array.length)\n *\n * @param Array\n * @return Array\n */\nvar auxiliaryCountingSort = function (array, mod) {\n  var length = array.length;\n  var bucket = [];\n  var i;\n\n  for (i = 0; i < 10; i++) {\n    bucket[i] = [];\n  }\n\n  for (i = 0; i < length; i++) {\n    var digit = parseInt((array[i].key / Math.pow(10, mod)).toFixed(mod)) % 10;\n    bucket[digit].push(array[i]);\n  }\n\n  var pointer = 0;\n\n  for (i = 0; i < 10; i++) {\n    var localLength = bucket[i].length;\n\n    for (var j = 0; j < localLength; j++) {\n      array[pointer++] = bucket[i][j];\n    }\n  }\n\n  return array;\n};\n\n/**\n * Finds the maximum key from an array of objects\n *\n * Asymptotic Complexity: O(array.length)\n *\n * @param Array\n * @return Integer if array non-empty\n *         Undefined otherwise\n */\nvar maximumKey = function (a) {\n  var max;\n  for (var i = 1; i < a.length; i++) {\n    if (max === undefined || a[i].key > max) {\n      max = a[i].key;\n    }\n  }\n  return max;\n};\n\nmodule.exports = radixSort;\n","/home/travis/build/npmtest/node-npmtest-algorithms/node_modules/algorithms/algorithms/sorting/insertion_sort.js":"'use strict';\nvar Comparator = require('../../util/comparator');\n\n/**\n * Insertion sort algorithm O(n + d)\n */\nvar insertionSort = function (vector, comparatorFn) {\n  var comparator = new Comparator(comparatorFn);\n\n  for (var i = 1, len = vector.length; i < len; i++) {\n    var aux = vector[i],\n      j = i;\n\n    while (j > 0 && comparator.lessThan(aux, vector[j - 1])) {\n      vector[j] = vector[j - 1];\n      j--;\n    }\n\n    vector[j] = aux;\n  }\n\n  return vector;\n};\n\nmodule.exports = insertionSort;\n","/home/travis/build/npmtest/node-npmtest-algorithms/node_modules/algorithms/algorithms/sorting/shell_sort.js":"'use strict';\nvar Comparator = require('../../util/comparator');\n/**\n * shell sort  worst:O(n lg n)  best:O(n)\n */\nvar shellSort = function (array, comparatorFn) {\n  var comparator = new Comparator(comparatorFn),\n    begin = 0,\n    end = array.length - 1,\n    gap = parseInt((end - begin + 1) / 2),\n    i = 0, j = 0, temp = 0;\n\n  while (gap >= 1) {\n    for (i = begin + gap;i <= end;i += 1) {\n      temp = array[i];\n      j = i - gap;\n      while (j >= begin && comparator.greaterThan(array[j], temp)) {\n        array[j + gap] = array[j];\n        j = j - gap;\n      }\n      array[j + gap] = temp;\n    }\n    gap = parseInt(gap / 2);\n  }\n\n  return array;\n};\n\nmodule.exports = shellSort;\n","/home/travis/build/npmtest/node-npmtest-algorithms/node_modules/algorithms/string.js":"'use strict';\n\n// String algorithms\nmodule.exports = {\n  levenshtein: require('./algorithms/string/levenshtein'),\n  rabinKarp: require('./algorithms/string/rabin_karp'),\n  knuthMorrisPratt: require('./algorithms/string/knuth_morris_pratt'),\n  huffman: require('./algorithms/string/huffman'),\n  hamming: require('./algorithms/string/hamming'),\n  longestCommonSubsequence: require(\n    './algorithms/string/longest_common_subsequence'),\n  longestCommonSubstring: require(\n      './algorithms/string/longest_common_substring')\n};\n","/home/travis/build/npmtest/node-npmtest-algorithms/node_modules/algorithms/algorithms/string/levenshtein.js":"'use strict';\n\n/**\n * Calculates the edit distance between two strings\n * considering the same cost of 1 to every operation\n * (addition, deletion, substitution)\n *\n * It uses dynamic programing and creates a matrix\n * where every cell [i,j] represents the distance between\n * the substrings a[0..i] and b[0..j]\n *\n * O(a.length * b.length)\n *\n * @param String\n * @param String\n * @return Number\n */\nvar levenshtein = function (a, b) {\n  var editDistance = [];\n  var i, j;\n\n  // Initialize the edit distance matrix. The first collumn contains\n  // the values comparing the string a to an empty string b\n  for (i = 0; i <= a.length; i++) {\n    editDistance[i] = [];\n    editDistance[i][0] = i;\n  }\n\n  // And the first line the values comparint the string b to an empty string a\n  for (j = 0; j <= b.length; j++) {\n    editDistance[0][j] = j;\n  }\n  for (i = 1; i <= a.length; i++) {\n    for (j = 1; j <= b.length; j++) {\n      // Finds the minimum cost for keeping the two strings equal\n      editDistance[i][j] =\n        Math.min(\n          editDistance[i - 1][j - 1], // if we replace a[i] by b[j]\n          editDistance[i - 1][j], // if we delete the char from a\n          editDistance[i][j - 1] // if we add the char from b\n        ) +\n        (a[i - 1] !== b[j - 1] ? 1 : 0);\n    }\n  }\n\n  return editDistance[a.length][b.length];\n};\n\nmodule.exports = levenshtein;\n","/home/travis/build/npmtest/node-npmtest-algorithms/node_modules/algorithms/algorithms/string/rabin_karp.js":"'use strict';\n\n/**\n * A prime number used to create\n * the hash representation of a word\n *\n * Bigger the prime number,\n * bigger the hash value\n */\nvar base = 997;\n\n/**\n * Calculates String Matching between two Strings\n * Returns true if String 'b' is contained in String 'a'\n *\n * Average and Best Case Complexity: O(a.length + b.length)\n * Worst Case Complexity: O(a.length * b.length)\n *\n * @param String\n * @param String\n * @return Integer\n */\nvar rabinKarp = function (s, pattern) {\n  if (pattern.length === 0) return 0;\n\n  var hashPattern = hash(pattern);\n  var currentSubstring = s.substring(0, pattern.length);\n  var hashCurrentSubstring;\n\n  for (var i = pattern.length; i <= s.length; i++) {\n    if (hashCurrentSubstring === undefined) {\n      hashCurrentSubstring = hash(currentSubstring);\n    } else {\n      /*\n       * Re-hash\n       * Recalculates the hash representation of a word so that it isn't\n       * necessary to traverse the whole word again\n       */\n      hashCurrentSubstring -= currentSubstring.charCodeAt(0) *\n        Math.pow(base, pattern.length - 1);\n      hashCurrentSubstring *= base;\n      hashCurrentSubstring += s.charCodeAt(i);\n\n      currentSubstring = currentSubstring.substring(1) + s[i];\n    }\n\n    if (hashPattern === hashCurrentSubstring &&\n        pattern === currentSubstring) {\n      // Hack for the off-by-one when matching in the beginning of the string\n      return i === pattern.length ? 0 : i - pattern.length + 1;\n    }\n  }\n\n  return -1;\n};\n\n/**\n * Creates the hash representation of 'word'\n *\n * @param String\n * @return Number\n */\nvar hash = function (word) {\n  var h = 0;\n\n  for (var i = 0; i < word.length; i++) {\n    h += word.charCodeAt(i) * Math.pow(base, word.length - i - 1);\n  }\n\n  return h;\n};\n\nmodule.exports = rabinKarp;\n","/home/travis/build/npmtest/node-npmtest-algorithms/node_modules/algorithms/algorithms/string/knuth_morris_pratt.js":"'use strict';\n\n/**\n * String Matching algorithm\n * Tries to match the given pattern inside the given text\n * If the pattern exists inside the text, it will be returned\n * the index of the begining of the pattern in the text,\n * otherwise it will be returned the length of the text\n *\n * Asymptotic Complexity: O(text.length)\n *\n * @param {Array} text of Numbers, Strings or Characters\n *     or {String}\n * @param {Array} pattern of Numbers, Strings or Characters\n *     or {String}\n * @return {Number}\n */\nvar knuthMorrisPratt = function (text, pattern) {\n  var textLength = text.length;\n  var patternLength = pattern.length;\n  var m = 0;\n  var i = 0;\n  var table = buildTable(pattern);\n\n  while (m + i < textLength) {\n    if (pattern[i] === text[m + i]) {\n      if (i === patternLength - 1) {\n        return m;\n      }\n      ++i;\n    }\n    else {\n      if (table[i] >= 0) {\n        i = table[i];\n        m = m + i - table[i];\n      }\n      else {\n        i = 0;\n        ++m;\n      }\n    }\n  }\n\n  return textLength;\n};\n\n/**\n * Builds the dinamic table of the given pattern\n * to record how the pattern can match it self\n *\n * Asymptotic Complexity: O(pattern.length)\n *\n * @param {Array} pattern of Numbers, Strings or Characters\n *     or {String}\n * @return {Array} of Integers\n */\nvar buildTable = function (pattern) {\n  var length = pattern.length;\n  var table = [];\n  var position = 2;\n  var cnd = 0;\n\n  table[0] = -1;\n  table[1] = 0;\n\n  while (position < length) {\n    if (pattern[position - 1] === pattern[cnd]) {\n      ++cnd;\n      table[position] = cnd;\n      ++position;\n    }\n    else if (cnd > 0) {\n      cnd = table[cnd];\n    }\n    else {\n      table[position] = 0;\n      ++position;\n    }\n  }\n\n  return table;\n};\n\nmodule.exports = knuthMorrisPratt;\n","/home/travis/build/npmtest/node-npmtest-algorithms/node_modules/algorithms/algorithms/string/huffman.js":"'use strict';\n\n\nvar huffman = {};\n\n\n/**\n * Maximum block size used by functions \"compress\", \"decompress\".\n *\n * @const\n */\nvar MAX_BLOCK_SIZE = (-1 >>> 0).toString(2).length;\n\n\n/**\n * Compress 0-1 string to int32 array.\n *\n * @param {string} string\n * @return {number[]}\n */\nvar compress = function (string) {\n  var blocks = [];\n  var currentBlock = 0, currentBlockSize = 0;\n\n  string.split('').forEach(function (char) {\n    currentBlock = (currentBlock << 1) | char;\n    currentBlockSize += 1;\n\n    if (currentBlockSize === MAX_BLOCK_SIZE) {\n      blocks.push(currentBlock);\n      currentBlock = currentBlockSize = 0;\n    }\n  });\n\n  // Append last block size to the end.\n  if (currentBlockSize) {\n    blocks.push(currentBlock, currentBlockSize);\n  }\n  else {\n    blocks.push(MAX_BLOCK_SIZE);\n  }\n\n  return blocks;\n};\n\n\n/**\n * Decompress int32 array back to 0-1 string.\n *\n * @param {number[]} array\n * @return {string}\n */\nvar decompress = function (array) {\n  if (!array.length) {\n    return '';\n  }\n  else if (array.length === 1) {\n    throw new Error('Compressed array must be either empty ' +\n                    'or at least 2 blocks big.');\n  }\n\n  var padding = new Array(MAX_BLOCK_SIZE + 1).join(0);\n\n  var string = array.slice(0, -2).map(function (block) {\n    return (padding + (block >>> 0).toString(2)).slice(-padding.length);\n  }).join('');\n\n  // Append the last block.\n  var lastBlockSize = array.slice(-1)[0];\n  var lastBlock = array.slice(-2)[0];\n  string += (padding + (lastBlock >>> 0).toString(2)).slice(-lastBlockSize);\n\n  return string;\n};\n\n\n/**\n * Apply Huffman encoding to a string.\n *\n * @param {string} string\n * @param {boolean} [compressed=false] - Whether compress the string to bits.\n * @return {{encoding: Object.<string, string>, value: string|number[]}}\n */\nhuffman.encode = function (string, compressed) {\n  if (!string.length) {\n    return {\n      encoding: {},\n      value: (compressed ? [] : '')\n    };\n  }\n\n  var counter = {};\n  string.split('').forEach(function (char) {\n    counter[char] = (counter[char] || 0) + 1;\n  });\n\n  var letters = Object.keys(counter).map(function (char) {\n    return {\n      char: char,\n      count: counter[char]\n    };\n  });\n\n  var compare = function (a, b) {\n    return a.count - b.count;\n  };\n  var less = function (a, b) {\n    return a && (b && (a.count < b.count) || !b);\n  };\n\n  letters.sort(compare);\n\n  // Each time two least letters are merged into one, the result is pushing into\n  // this buffer. Since the letters are pushing in ascending order of frequency,\n  // no more sorting is ever required.\n  var buffer = [];\n  var lettersIndex = 0, bufferIndex = 0;\n\n  var extractMinimum = function () {\n    return less(letters[lettersIndex], buffer[bufferIndex]) ?\n      letters[lettersIndex++] : buffer[bufferIndex++];\n  };\n\n  for (var numLetters = letters.length; numLetters > 1; --numLetters) {\n    var a = extractMinimum(), b = extractMinimum();\n    a.code = '0';\n    b.code = '1';\n    var union = {\n      count: a.count + b.count,\n      parts: [a, b]\n    };\n    buffer.push(union);\n  }\n\n  // At this point there is a single letter left.\n  var root = extractMinimum();\n  root.code = (letters.length > 1) ? '' : '0';\n\n  // Unroll the code recursively in reverse.\n  (function unroll(parent) {\n    if (parent.parts) {\n      var a = parent.parts[0], b = parent.parts[1];\n      a.code += parent.code;\n      b.code += parent.code;\n      unroll(a);\n      unroll(b);\n    }\n  })(root);\n\n  var encoding = letters.reduce(function (acc, letter) {\n    acc[letter.char] = letter.code.split('').reverse().join('');\n    return acc;\n  }, {});\n\n  // Finally, apply the encoding to the given string.\n  var result = string.split('').map(function (char) {\n    return encoding[char];\n  }).join('');\n\n  return {\n    encoding: encoding,\n    value: (compressed ? compress(result) : result)\n  };\n};\n\n\n/**\n * Decode a Huffman-encoded string or compressed number sequence.\n *\n * @param {Object.<string, string>} encoding - Maps characters to 0-1 sequences.\n * @param {string|number[]} encodedString\n * @return {string} Decoded string.\n */\nhuffman.decode = function (encoding, encodedString) {\n  if (Array.isArray(encodedString)) {\n    encodedString = decompress(encodedString);\n  }\n\n  // We can make use of the fact that encoding mapping is always one-to-one\n  // and rely on the power of JS hashes instead of building hand-made FSMs.\n  var letterByCode = Object.keys(encoding).reduce(function (acc, letter) {\n    acc[encoding[letter]] = letter;\n    return acc;\n  }, {});\n\n  var decodedLetters = [];\n\n  var unresolved = encodedString.split('').reduce(function (code, char) {\n    code += char;\n    var letter = letterByCode[code];\n    if (letter) {\n      decodedLetters.push(letter);\n      code = '';\n    }\n    return code;\n  }, '');\n\n  if (unresolved) {\n    throw new Error('Invalid string to decode.');\n  }\n\n  return decodedLetters.join('');\n};\n\n\nmodule.exports = huffman;\n","/home/travis/build/npmtest/node-npmtest-algorithms/node_modules/algorithms/algorithms/string/hamming.js":"/**\n *\n * \"Hamming distance between two strings of equal length is the number of\n * positions at which the corresponding symbols are different. In another way,\n * it measures the minimum number of substitutions required to change one string\n * into the other.\" - https://en.wikipedia.org/wiki/Hamming_distance\n *\n */\n'use strict';\n\nvar hamming = function (a, b) {\n  if (a.length !== b.length) {\n    throw new Error('Strings must be equal in length');\n  }\n\n  var dist = 0;\n\n  for (var i = 0; i < a.length; i++) {\n    if (a[i] !== b[i]) {\n      dist++;\n    }\n  }\n\n  return dist;\n};\n\nmodule.exports = hamming;\n","/home/travis/build/npmtest/node-npmtest-algorithms/node_modules/algorithms/algorithms/string/longest_common_subsequence.js":"/**\n * Implementation of longest common subsequence\n */\n\n'use strict';\n\n/**\n * Implementation via dynamic programming\n */\nvar longestCommonSubsequence = function (s1, s2) {\n  // Multidimensional array for dynamic programming algorithm\n  var cache = new Array(s1.length + 1);\n\n  var i, j;\n\n  for (i = 0; i <= s1.length; i++) {\n    cache[i] = new Int32Array(s2.length + 1);\n  }\n\n  // Fill in the cache\n  for (i = 1; i <= s1.length; i++) {\n    for (j = 1; j <= s2.length; j++) {\n      if (s1[i - 1] === s2[j - 1]) {\n        cache[i][j] = cache[i - 1][j - 1] + 1;\n      } else {\n        cache[i][j] = Math.max(cache[i][j - 1], cache[i - 1][j]);\n      }\n    }\n  }\n\n  // Build LCS from cache\n  i = s1.length;\n  j = s2.length;\n  var lcs = '';\n\n  while (cache[i][j] !== 0) {\n    if (s1[i - 1] === s2[j - 1]) {\n      lcs = s1[i - 1] + lcs;\n      i--;\n      j--;\n    } else if (cache[i - 1][j] > cache[i][j - 1]) {\n      i--;\n    } else {\n      j--;\n    }\n  }\n\n  return lcs;\n};\n\nmodule.exports = longestCommonSubsequence;\n","/home/travis/build/npmtest/node-npmtest-algorithms/node_modules/algorithms/algorithms/string/longest_common_substring.js":"/**\n * Implementation of longest common substring\n */\n\n'use strict';\n\n/**\n * Implementation via dynamic programming\n */\nvar longestCommonSubstring = function (s1, s2) {\n  // Multidimensional array for dynamic programming algorithm\n  var cache = new Array(s1.length + 1);\n\n  var i, j;\n\n  for (i = 0; i <= s1.length + 1; i++) {\n    cache[i] = new Int32Array(s2.length + 1);\n  }\n\n  var lcsPosition = {};\n  var lcsLength = 0;\n\n  // Fill in the cache\n  for (i = 1; i <= s1.length; i++) {\n    for (j = 1; j <= s2.length; j++) {\n      if (s1[i - 1] === s2[j - 1]) {\n        cache[i][j] = cache[i - 1][j - 1] + 1;\n        if (cache[i][j] > lcsLength) {\n          lcsPosition.i = i;\n          lcsPosition.j = j;\n          lcsLength = cache[i][j];\n        }\n      } else {\n        cache[i][j] = 0;\n      }\n    }\n  }\n\n  var lcs = '';\n  if (lcsLength) {\n    lcs = s1.substring(lcsPosition.i - lcsLength, lcsPosition.i);\n  }\n\n  return lcs;\n};\n\nmodule.exports = longestCommonSubstring;\n"}